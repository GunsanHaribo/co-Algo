# 문제 (회고 필요)
~~~text
**중앙값(Median)**은 정렬된 정수 리스트에서 가운데에 위치한 값입니다.
리스트의 크기가 홀수라면 가운데 값이 중앙값이고, 짝수라면 가운데 두 값의 평균이 중앙값입니다.

예를 들어, arr = [2,3,4]일 때 중앙값은 3입니다.
예를 들어, arr = [2,3]일 때 중앙값은 (2 + 3) / 2 = 2.5입니다.

MedianFinder 클래스를 구현하세요:
	•	MedianFinder()는 MedianFinder 객체를 초기화합니다.
	•	void addNum(int num)은 데이터 스트림에서 정수 num을 데이터 구조에 추가합니다.
	•	double findMedian()은 지금까지 입력된 모든 요소의 중앙값을 반환합니다. 
	실제 정답과의 오차가 10^-5 이내면 정답으로 처리됩니다.
~~~

## 문제 분석
1. 미지 : 중앙값 반환
2. 자료 : 정수 리스트 
3. 조건 : 
- 리스트의 크기가 홀수라면 "가운데 값이 중앙값" 
- 짝수라면 "가운데 두 값의 평균"이 중앙 값

## 문제 풀이 

### 1. Example
~~~text
Input
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
Output
[null, null, null, 1.5, null, 2.0]

Explanation
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
~~~

1. 중앙값 구하는 기능 
2. 순서를 보장해서 넣는걸 가져와야한다. sort을 매번하니 prioirty 사용합니다.
3. 다만, 중앙값을 구하기 위해 계속 넣어다가 뺼 수는 없다. -> 이럴꺼면 딴거 쓰지 
4. 짝수 일떄는 두개 힙만들어주면 가능 
5. 홀수 일떄는 가운데 인덱스를 뽑기위해 배열로 변환 -> toArray는 정렬된 값을 반환하지 못함
6. 1, 2 -> 만 들어가 있으면 이거 사용한다.

---------------
- 예시가 1, 5, 7, 100 이라면 
- 5,7 -> 12 
- 가운데 값 기준으로 나눌 수 있다면 나눌 수 있으면 나누는데 
- (1,5 | 7, 100)면 좋겠는데, 하나는 max로 하나는 min으로
-------------------------------------  ( max   |   min )
- 100이 들어왔을떄 7보다 크므로 min 큐로 들어간다. -> 1, 5  |  7, 100
- 7이 들어왔을때 5보다 크므로 5큐에 들어갑니다. ->  1, 5 | 7 
- 1 | 5 7  -> 두 사이즈 중에 : min이 더크면 옮김니다. poll해서 이동합니다.  
- 5가 들어왔을떄, 1보다 크므로 다른 큐에 들어갑니다. ->  1 | 5
- 1이 들어왔을때 max큐에 들어갑니다. ->  1 : 여기에 들어가서 사이즈가 작은경우 옮겨옵니다.  
- 근데 이게 순차적으로 들어가는진 모르겠다. 아무튼 min, max에서 뽑으면 되유, count 세면서 뽑으면 될뜻 

---------------
- 1, 5, 7, 10, 100
- 100 들어가면 10?보다 더크므로 minHeap에 들어갑니다. 1,5,7 | 10, 100
- 1, 5 | 7, 10, 100 -> (1, 5, 7 | 10 ,100) : (max < min)이면 min에서 넘겨줘야합니다. 
- 10이 들어가면    1, 5 | 7, 10 
- 7이 들어가면    1 | 5, 7 -> 1, 5 | 7
- 5가들어가면  1 | 5
- 1 | 
------------------
- 1, 5, 2, 7, 10, 100
- 1, 2, 5 | 7, 10, 100
- 1, 2, 5 | 7, 10   -> 10 (사이즈가 크면 왼쪽으로)
- 1,2 | 5, 7, 10  -> 10 들어감 
- 1, 2, | 5, 7         -> 7들어감  (max보다 크면 오른쪽으로)
- 1, 2 | 5  -> 2 들어감 (들어가는데 사이즈가 안맞으면 왼쪽으로)
- 1 | 5   ->  5 들어감 (크면 max로 들어간다)  : ( | 1 5)
- 1 | 0    -> ( 1 | 0 ) -> 아무것도 없으면 max부터 들어감    
----------------
- 7, 5, 2, 1, 10, 100 -> 1, 2, 5 | 7, 10, 100
- 1, 2, 5 | 7, 10  -> 100
- 1, 2, 5 | 7   -> 10
- 2, 5  | 7  ->  1 -> 7보다 작으면 넣어준다 -> 다만 사이즈가 크면 뽑아서 준다 
- 2, 5  |  7   ->   7보다 작으면 넣어준다   (max > min +1) 이면 바꾼다 
- 5, 7 |  0   -> 5   :  근데 사이즈가 안맞는다? 다시 뺴서 온다 ( 5 | 7) -> (max > min +1)
- 7 | 0   -> 수가 들어왔을때 

## 너무 복잡하게 풀었음 
- 그냥 숫자를 아무곳에나 넣어줬어도 자동으로 비교했을거고
- 아무데나 넣은 숫자를 바탕으로 큐를 재조정했으면은 제대로 작동했을껏 같음
- 지금 만든 예시대로 하긴하는데 너무 경우의 수를 갈라놓았음 
- 일반화를 할 예시가 부족해서 예시를 추가한건데 
- 오히려 일반화가 잘 안되고 예시만 맞춰서 진행한느낌 

## 문제지 풀이
오른쪽에 넣고 오른쪽 큐가 더 크면 왼쪽으로 옮기는 방법


## 링크  
https://leetcode.com/problems/find-median-from-data-stream/submissions/1631573547