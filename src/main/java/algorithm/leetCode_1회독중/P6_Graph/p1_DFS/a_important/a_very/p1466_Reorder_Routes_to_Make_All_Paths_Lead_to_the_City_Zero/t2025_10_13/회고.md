# 풀이규칙
1. 연습문제는 최대 1시간
2. 실전문제는 무제한

# 분석

1. 미지 : 변경된 간선의 최소 개수를 반환
2. 자료 : connections -> 간선 행렬 -> 인접리스트 전환 필요, 방향 그래프임
3. 조건 : 
   1. 시간 복잡도(3억)
      - 5 * 10^4 제곱하면 위험함  NlogN까지 가능
   2. 키워드
      - 각 도시가 수도를 방문할 수 있도록 도로의 방향을 바꾼다. -> 이것의 최소 갯수
4. 전단계
   - 출력 : 3
   - 순회는 해야됨, 
   - 원하는건 이거
     - 5 : 4
     - 4 : 0
     - 3 : 1
     - 2 : 3
     - 1 : 0
   - 무방향 그래프 
     - 5 : 4
     - 4 : 5, 0
     - 3 : 2, 1
     - 2 : 3
     - 1 : 0
   - 현재 방향 그래프(이걸로 잡고)
     - 5 : 
     - 4 : 0
     - 3 : 
     - 2 : 3
     - 1 : 3
   - 서로 다른게 3개 : 5 -> 4, 3 -> 1, 1 -> 0
5. 기능 
   - 유방향 그래프를 무방향 그래프로 변경하기 
   - 무방향 그래프로 각자 노드에서 0으로 가는 루트 구하기 or 0에서 각자 노드로 가던지(리버스로 저장하면 되니깐)
     - 무방향 그래프 만들기
     - 0으로 가는 루트 기록하고 HashMap에 넣어두기
     - 5- > 4
     - 2 -> 3 -> 1 -> 0 이면, 2->3, 3-> 1, 1->0 으로 만들어야함
     - 이게 각노드를 기록한 HashMap에서 0을 갈수 없는 노드들을 뺴는게 0에 도착할 수 없음을 알았을떄, 도달한 지점을 뺴는게 가능하지 않다.
     - List로 기록하던가 해야되는데 너무 꼬일 것 같음
   - 0에서 각 노드로 가는 방법도 있음
     - 0 -> 1 -> 3 -> 2
     - 0 -> 4 -> 5
     - 하고 다 도착했으면(?), seen으로 묶어 놓고 갈데가 없으면 그떄 부터 해체?
     - 아니면 0,4로 들어가면 들어오면 이전 노드랑 현재 노드 매개변수에 넣어서 거꾸로 HashMap에 넣자
- 기능 
1. 무방향 그래프 만들기
2. 0에서 부터 각 노드 따라서 이동 -> 이동 가능하면 HashMap에 거꾸로 기록하기, +) 이미 방문한 노드는 seen으로 방문처리
3. 처음 유방향 그래프하고 비교합니다. 각 키의 value에서 없는거 count
   
근데 이렇게 하려면 각 노드마다 0으로 가는길이 하나로 정해져 있어야 되긴 하는데

# 패턴
- “루트에서 DFS/BFS로 내려가며, (부모→자식)이 ‘원래 방향’이면 그 간선은 루트에서 멀어지는 중이므로 1 카운트.”
```text
import java.util.*;

class RootReorient {
  private List<Integer>[] graph;
  private Set<Long> roads;   // 원래 방향 u->v 저장
  private int root = 0;

  public int solve(int n, int[][] directedEdges, int root) {
    this.root = root;
    graph = new ArrayList[n];
    for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();
    roads = new HashSet<>();

    // 1) 원래 방향 저장 + 2) 무방향 그래프 구성
    for (int[] e : directedEdges) {
      int u = e[0], v = e[1];
      roads.add(key(u, v));     // 원래 방향 u->v
      graph[u].add(v);
      graph[v].add(u);
    }

    // 3) 루트에서 DFS. (parent -> child)가 원래 u->v면 flip++
    return dfs(root, -1);
  }

  private int dfs(int node, int parent) {
    int flips = 0;
    for (int nei : graph[node]) {
      if (nei == parent) continue;
      // node -> nei가 원래 방향이면 (루트에서 멀어짐) → 뒤집기 필요
      if (roads.contains(key(node, nei))) flips++;
      flips += dfs(nei, node);
    }
    return flips;
  }

  // (u,v)를 충돌 없이 long 키로 인코딩
  private long key(int u, int v) {
    return (((long) u) << 32) | (v & 0xffffffffL);
  }
}

```


https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/submissions/1799549803

---

# 회고(순회하면서 count)
- `0` 에서 **멀어지는** 방향으로 순회할 수 있으며, 간선이 `0` 에서 멀어지는 방향을 가리키는 것을 볼 때마다 교환해야 한다는 것을 알 수 있음을 의미합니다
- 미리 무방향 그래프랑 단방향 저장 해놓고, 0에서 멀어지는 무방향 그래프 이동할때, 멀어지는 방향이 기존에 유방향 그래프에 존재하는지 확인하고 count
- 순회를 할떄, 미리 저장을 해두었더라면 볼 수 있었을 것 같은데, 이 문제의 미지?는 뭐였지?그러면,
- 출력이 3일떄 2일때 1일때에도 다 만들어 놓고 비교하는 방법 외에, count를 순회하면서 해보기
- 이게 큰듯 : toZeroReverseGraph를 만들어 역방향 그래프를 굳이 저장했다가 비교하는 건 과정이 길다 → DFS 중 바로 roads.contains(parent→child) 로 카운트하면 끝.
- HashSet<String> 대신 숫자 인코딩(long)으로 키를 만들면 메모리/속도 모두 유리. -> 그렇다고함
