# 핵심
- 미지를 반환(여기서는 노드 그자체)
- 없음은 null로 표현

# 분석

1. 문제 : 두노드의 최소 공통 조상 찾기 -> 공통 조상 노드
2. 자료 : 이진트리 하나, p,q 두 노드
3. 조건 :

- 최소 공통 조상 : 두 노드를 포함하는 노드 중에 가장 높이가 낮은 노드

# 풀이 + 예상동작

1. 두 노드를 포함하는지 확인하는 기능 -> 탐색
    1. 두 노드의 공통 조상, 자식 중에 p,q가 있는지 확인 하는 작업이 필요
    2. 있으면 부모를 올려 줍니다.
2. 만약에 자식 중에 p,q가 하나라도 없다면
    1. 아니다 없으면 안들어가도되네
    2. 있을 경우에만 if 문으로 들어가면 되겠네

# 디버깅(예상과 다르면)

1. 내가 생각하는건, 부모랑 왼쪽 오른쪽 비교하는 거였는데
2. 부모에 있을 경우도 고려를 해야되네, 지금 4만 true로 나와서 4만 올라가네

# 회고(답지와 비교)

1. “탐색은 top-down, 반환은 bottom-up”
- 	•	연산 자체(탐색, 비교)는 부모 → 자식 방향으로 내려가면서 수행된다.
     •	하지만 결과(찾은 노드, 조상 여부)는 자식 → 부모 방향으로 올라오면서 결합된다.
     •	즉, “탐색은 top-down, 반환은 bottom-up” 구조라는 점을 명확히 인식해야 한다.
2. 반환은 자식 -> 부모, 반환값의 타입을 먼저 정해야함(null 포함)
- 	•	재귀 함수를 설계할 때 가장 먼저 해야 할 건 반환값이 어떤 의미를 가질지 정의하는 것이다.
     •	이 문제에서는 null, p/q, LCA 세 가지 케이스로 충분했다.
     •	반환 타입을 명확히 정의하지 않고 sentinel(특수 값)이나 Set(외부 상태)에 의존하면 로직이 꼬인다.
3. 정리
- 	•	연산과 반환의 방향이 다르다 → 내려가면서 조건을 확인, 올라오면서 답을 결합.
     •	리턴 계약을 먼저 정한다 → 반환값의 의미를 단순화(null/타겟/정답).
     •	불필요한 상태 공유 제거 → 전역 Set이나 sentinel 대신 반환값 자체로 모든 정보를 표현한다.


-----
서브트리에 정답이 있고 맨 위의 루트의 입장에서는 left != , right != 일떄
left, right 중에 하나는 정답인데, 루트 입장에서는 둘다 아니여서 애매할떄 -> 서브트리가 정답일떄
------------------------------------------------------

1. 답지 풀이

- 2~3번째가 상당히 생각하기 어려운 방법인데...
- 아 그리고 == p이거 바로 못씁니다. 현재 내가 구상한 거에는 메모리가 달라서 eqauls()같은거 써야합니다.(이건 구현되어 있을라나?)
- 트리의 재귀적 특성 때문에, 우리는 케이스들을 알고리즘으로 변환할 수 있습니다

2. 케이스 3가지

- 루트 노드가 `p` 또는 `q` 입니다. 답은 루트 노드 아래에 있을수 없습니다. => 루트가 답일떄
- `p` 또는 `q` 중 하나가 왼쪽 서브트리에 있고, 다른 하나는 오른쪽 서브트리에 있습니다. 루트는 두 서브트리 사이의 연결 지점이므로 답이 되어야 합니다. => 루트가 답일떄
- `p` 와 `q` 모두가 하나의 서브트리에 있습니다. 이 경우, 루트는 답이 아닙니다. 서브트리 내부를 살펴보고 "더 낮은"노드를 찾아야합니다. =>> 애가 관건이었는데

3. 풀이

- 첫 번째 경우에서, 현재 노드가 `p` 또는 `q` 중 하나라는 것을 알게 되면, 서브트리에 대해 전혀 걱정할 필요가 없습니다.
  답이 그 안에 있을 수 없다는 것을 알기 때문입니다. 따라서, 즉시 무언가(null이 아닌)를 반환할 수 있습니다. 기본 케이
  스에서는 `null` 을 반환합니다. 따라서, 서브트리에 대한 호출은 `p` 또는 `q` 중 하나가 해당 서브트리에 있는 경우에만
  null이 아닌 값을 반환합니다. `p`도`q`도 포함하지 않는 서브트리에 대해서는 `null` 을 반환해야 합니다.
- 그런 다음, 왼쪽과 오른쪽 서브트리에 대한 두 호출 모두 null이 아닌 것을 반환하면 두 번째 경우가 암시되고, 호출 중
  하나만 무언가를 반환하면 세 번째 경우가 암시됩니다. -> 없으면 null이여서 null이 아닌 경우만 올려주겠다.

4. 회고 
- 베이스 컨디션에서 없는 노드를 null로 반환할 생각을 못해서 나온 문제 같은데
- null로 할지 아니면 다른 숫자로 할지 어떻게 감을 잡아야할까?, 고민이 되는구만
  - null로 처리를 안했어도 타겟에 해당하는 노드가 없으면 그거 바탕으로 어떻게 처리할건지 그게 문제였나
  
---

5. 고칠점 
-  함수가 반환할 수 있는 값의 케이스를 먼저 정하라
```text
1. 항상 함수 리턴의 의미를 먼저 정의
   •	“이 함수는 null / 찾은 노드 / LCA 중 하나를 반환한다”
   •	리턴값이 여러 의미를 뒤섞지 않도록!
2.	없음은 sentinel 말고 null
    •	null은 “없음”의 자연스러운 신호 → if/else 분기 단순화
    •	sentinel을 쓰면 “없음”과 “값이 있는 특별한 경우”가 섞여 버려서 조건문이 꼬임
```
- 스니펫 
```text
TreeNode dfs(TreeNode n) {
    if (n == null) return null;
    if (n == p || n == q) return n; // 문제별로 target 조건
    TreeNode L = dfs(n.left);
    TreeNode R = dfs(n.right);
    if (L != null && R != null) return n;  // 결합 규칙
    return L != null ? L : R;              // 단순 반송
}
```


set 풀이 : https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/submissions/1756486055
null 풀이 : https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/submissions/1756520438