# 1시간 넘으면 답지봐
## 진짜 길어도 2시간

# 유형
- 유사트리, 조상 갱신(자식 여러개), 형제 연산, 레벨의 경계, 단조성:node.val 비교

# 분석

1. 미지 : 리프 유사 트리 인가? 
2. 자료 : 이진트리 2개 
3. 조건(결과는 역방향, 조건은 정방향, N+1) : 
- 리프노드의 순서가 같으면 리튜 유사트리로 간주
  - 리프 노드까지 내려가서 비교해야함 -> 리프노드 => (left == null, right == null인 트리)
  - 이걸 어떻게 비교하면 좋을까...왼쪽 오른쪽 그것처럼 할 순 없긴하넫
  - 서로 유사하면 T를 반환해야 되긴하는데 
    - T를 다 올려줬는가?, 아니면 뭐 두개 비교하던가
  - 그니깐 리프노드를 탐색하는 기능이 있어야함, 리프노드
    - 어떻게 다음 리프를 구하지? -> 다음리프를 구하는기능 따로 만들어야겠네\
  - 아니 이게 t를 올려줄 수가 없음, 부모 노드들이 다달라
  - 리프노드면 비교, 리프노드가 아니면 리프노드 찾아주기, 그런 다음에 비교
  - 

# 회고
- 두 개의 트리를 하나의 큰 트리라고 생각해도 될듯?
- 안풀리면 어떻게 하지근데, 막 엄청난 생각이 많이 안나는데, 이걸 어떻게 풀지는 모르겠는데
- 아 어려운데 이거 30분까지만 더 풀어볼까, 탐색하고 비교를 해야되는데 어떻게 하지이
--------
- 하나만 리프노드일떄가 살짝 헷갈리는데, 아 이거 케이스가 많이 헷갈리는데, 라우팅을 어디에 해줘야되는지도 헷갈리고
- 아니 뭐 리프만 꺼내주면 비교하기는 편하겠지, 근데 그거 말고 다른 방법으로 해보겠다는거 아니야
- 사고를 어떻게 바꿔줘야하지?, 다음 리프노드로 가게 해줘야 되는거아닌가?

- 다시 나갔다가 못 들어온다면 어떻게 할건데
--------
풀이와 고민은 업데이트 했습니다


https://leetcode.com/problems/leaf-similar-trees/submissions/1770905337
