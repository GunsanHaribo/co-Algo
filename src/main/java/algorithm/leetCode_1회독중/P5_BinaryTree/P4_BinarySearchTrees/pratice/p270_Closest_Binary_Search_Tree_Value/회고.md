~~~ text
270. 이진 탐색 트리에서 가장 가까운 값 찾기

이진 탐색 트리(root)와 하나의 target 값이 주어졌을 때, 
BST에서 target과 가장 가까운 값을 반환하시오.
만약 답이 여러 개라면, 더 작은 값을 출력하시오.
~~~

# IDE 자동완성 기능 사용하지 말기
# 분석

1. 미지 : BST에서 가장 가까운 값 반환 -> 절대 값 차이가 적어야한다 -> 최소 차이  
2. 자료 : BST root, target
3. 조건(결과는 역방향, 조건은 정방향) : 조상 갱신, 부모+형제 연산, 레벨의 경계, 라우팅
- 절대 값의 차이가 적어야한다. -> 이전에는 다 꺼내는 방식으로 했긴했는데
- 답이 여러개라면 작은 값을 출력

- 숫자 넣어주는 것도 나쁘지 않을 수도, 아니면 어차피 정렬되어 있는거니깐 들어갈 자리를 찾아주던가
- 들어갈 자리에 넣어주고 다 꺼내서 앞뒤에 숫자 중에 차이가 더 작은거 꺼내주면 되겠네,

----

트리로 안넣을거면, 다 꺼낸다음에 비교해야지 뭐, 
근데 노드가 이렇게 되버리면, int로 넣어버렸을떄 같은 수가 있으면 다행인데
1. 가장 가까운 정수로 반환을 한 다음
   - 있으면 반환 
   - 없으면 삽입 후 null 반환
2. null 반환시에 전체 중위 순회 이후 
   - 삽입한 숫자에 앞뒤를 추출
   - 앞뒤랑 원본 숫자의 차를 구한다음 차가 적은거 출력
   - 만약에 차가 같다면, 수가 작은 걸 출력-
----
위에꺼 너무 복잡함

1. 차가 가장 작은 걸 기록해, 아니 위에껀 너무 복잡해
2. 부모 왼쪽, 오른쪽 비교해서 더 작은 쪽으로 가야하나?
   - 차이가 적으면 유사한 숫자라는 건데, 그러면 그쪽으로 가는게 맞긴할듯 
   - 차이가 적은 쪽으로 이동하고 이동하고 차가 Min보다 적으면 Min 
   - 만약에 차가 같으면 작은 숫자로 이동 및 기록
----
이게 작은 쪽으로 갔을때 정답이 나오는이유는 이미 정렬이 되어있기 떄문인가? -> 내 생각은 그런데 아닐수도


# 회고
- 흐음.. 내가 생각하는게 맞는지는 모르겠네, GPT 한테 물어봐야겠다.
- leftNode, right Node로 라우팅을 하는것은 비추 
```text
      8
     / \
    7   50
        /
       9
target = 9.1
 •	네 코드: 루트 8에서 왼쪽갭 |7-9.1|=2.1, 오른쪽갭 |50-9.1|=40.9 → 왼쪽으로 감 → 7에서 끝 → 최종 8 or 7 근처…
 •	정답: target>8이므로 오른쪽 서브트리에서만 답을 찾음 → 9(Δ=0.1)가 최적.

“자식의 현재 값 거리”만 보면 오른쪽의 깊은 곳(9) 을 놓침
8로 나오긴하네
```
```text
이걸 “지도 탐색”으로 비유하면:
	•	BST는 정렬된 구간처럼 왼쪽은 작은 값들의 세계, 오른쪽은 큰 값들의 세계예요.
	•	내가 찾는 target이 현재 노드 값보다 작으면?
→ 당연히 작은 값들만 모여 있는 왼쪽 구간에서만 더 가까운 걸 찾을 수 있어요.
	•	반대로 크면?
→ 더 큰 값이 있는 오른쪽 구간으로만 가야 더 좋은 후보가 있을 수 있죠.

```

- 방향 결정은 오직 target과 node.val의 비교로 라우팅이 맞을듯
- 아.. 너무 휴리스틱적으로 가긴하는데, 