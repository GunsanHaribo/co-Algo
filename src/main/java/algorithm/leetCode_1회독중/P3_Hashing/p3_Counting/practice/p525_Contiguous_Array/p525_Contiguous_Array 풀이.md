# 문제

~~~text
이진 배열 nums가 주어졌을 때, 0과 1의 개수가 같은 연속 부분 배열의 최대 길이를 반환하세요.
~~~

## 문제 분석

1. 요구 : 연속 부분 배열의 / 최대 길이 반환
2. 자료 : 이진 배열 nums가 주어 졌을떄
3. 조건 :

- 0과 1의 갯수가 같아야한다

## 문제 풀이

### 1. Example

~~~text
Input: nums = [0,1,1,1,1,1,0,0,0]
Output: 6
Explanation: [1,1,1,0,0,0] is the longest contiguous subarray with equal number of 0 and 1.
~~~

1. 0을 -1로 변환(gpt 아이디어, 후에 슬라이싱 윈도우로 한번 풀어보기)
2. -1,1,1,1,1,1,-1,-1,-1
3. -1,0,1,2,3,4,3,2,1 -> 1-1이되는 마지막인덱스와 2번인덱스를 삭제한다
4. 1,1,0,0 -> 2,2 삭제
5. 1,0 -> 3,3 삭제

#### 성준님 조언

- 슬라이딩 윈도우 -> 조건이 명확할떄(01,1)
- Lr, rt의 움직임이 너무 명확하지 않을떄 -> 최대 합 이딴거 말고
- 움직이는 조건이 명확할떄 슬라이딩 윈도우 사용합니다.

#### 다른 풀이 -> 이렇게 구체적으로 하는것보다

##### 0,1의 갯수가 같을 수 있는방법을 찾는 것도 나쁘지 않겠다. 좀더 방법론적으로

[0,1,1,1,1,1,0,0,0]

1. [0,1], [1,1,0,0], [1,0], [1,1,1,0,0,0] -> 6이 해답
2. [1,1,1,0,0,0]의 이전 단계가 생각이 안났고(생각이 안난다면 개연추론으로)
    1. 지금 수들을 관찰했을때, 1,0이 대칭적입니다. -> 뒤집기는 투포인터 활용
    2. 그렇다면 뒤집고 나서 합했을때, 모든 수가 1이라면! -> 모두 1인지 확인하는 기능
        1. [0,1] + [1,0] -> [1,1]이면 0과1의 수가 같다
3. 그렇다면 이제 어떻게 수들을 이동 시켜야하나
    1. 일단 짝수배로 이동 시켜야한다, 순환하긴 해야될듯
    2. 0,1 -> 0,1,1,1, 0,1,1,1,1,1 => 0,1,1,1,1,1,0,0
        1. 되면 길이비교 안되면 left++;, right는 left기준으로 다시 조정
    3. 1,1 -> 1,1,1,1 => 애도 똑같이
    4. 1,1,1,0,0,0 ->  

#### 2. Example

~~~text
Input: nums = [0,1,0,1]
Output: 4
~~~

## 링크

https://leetcode.com/problems/contiguous-array/submissions/1608427721