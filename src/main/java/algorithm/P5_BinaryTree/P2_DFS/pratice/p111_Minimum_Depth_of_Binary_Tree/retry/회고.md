# 분석(있없)

1. 미지 : 최소 깊이 -> 깊이(어떤 숫자)
2. 자료 : 트리 하나
3. 조건 :

- 깊이 구하기 + 가까운지 확인
- 최소 깊이 : 루트 -> 가장 가까운 리프 노드
- 본인도 깊이에 포함

4. 분기 규칙

- 0 -> 없음
- Math.min()+1 둘다 있을떄
- Math.max() +1 한쪽이 없을떄

# 풀이 + 예상동작

1. left, right 중에 최소를 구해서 넘긴다.

# 디버깅(예상과 다르면)

# 회고(답지와 비교)

1. 분기 처리는 이진트리에서는 "없을때, 둘다 있을떄, 한쪽만 있을떄"로 나뉘나?
2. 트리는 “없음(null)”과 “있음(non-null)”이 본질적인 분기점

---
항상 저 3가지로만 고정되는 건 아니고, 문제 성격에 따라 더 세밀하게 나누기도 해요. 예를 들어:
•	리프 노드 여부를 따로 뽑아내기도 함 → (left == null && right == null)
•	균형 문제에서는 높이 차이까지 조건에 들어감
•	경로 합 문제에서는 현재 값 + 자식 합으로 분기
•	탐색 문제에서는 값 비교(target < root.val)로 왼쪽/오른쪽 재귀 여부를 결정

---
1. 계약 먼저: 반환값의 의미(0=빈/없는 경로, 1=리프)를 명확히.
2. 분기 규칙 단순화: “한쪽만 유효면 max+1, 양쪽 유효면 min+1”.
3. 전역/센티넬 지양: 읽히는 코드가 오류도 적다.
4. 미지 함수의 반환값을 상태 케이스로 쪼개서

https://leetcode.com/problems/minimum-depth-of-binary-tree/submissions/1757646600