# 분석

1. 미지(반환) : 트리의 최대 지름 -> depth != 지름
2. 자료 : 이진 트리 하나
3. 조건 :

- 경로 길이 :  두 노드 사이의 모서리 수(간선의 수)
- 지름 : 두 노드 사이의 가장 긴 경로의 길이 -> 가장 긴 경로(가장 긴 depth)

4. 미지 연산(조상 갱신, 형제 연산) :

- 지름을 구하려면 leftDepth, rightDepth 가 필요하긴함
- 근데 이게 왼쪽, 오른쪽 에서 올려준 지름하고 본인이 거치는 지름하고 비교해야함

# 풀이 + 예상동작

# 회고
근데 전역변수는 쓰기 싫은자

흐음...시간 복잡도가 박살이 났네
https://leetcode.com/problems/diameter-of-binary-tree/submissions/1757999893

---

이전꺼랑 다른 점은 이번에 밑으로 내려서 left, right 비교를 한게 아니긴하지
+1을 하던가 해댜될 것 같은데, 아니면 +2를 해줘서 비교만 하던가

연산을 밑으로 내리고 루트에서는 판단만 진행 -> 이건 baseCondition이 중요하네

---

연산 할떄 필요한 값을 던져주고, 계산은 루트에서 비교만 -> maxDepth와 유사하게 풀이하기
연산할때 필요한걸 던져주는 방햐으로 가는게 맞

---

1.	이 문제의 답을 계산하려면 조상 정보만 있으면 되나?
•	Yes → 내려보내기
•	예: 조상과 현재 노드의 차이, 경로 합, 경로 최소/최대
2.	아니면 왼쪽/오른쪽 자식의 정보를 합쳐야 하나?
•	Yes → 올려보내기
•	예: 지름, 균형 트리, 최대 경로합