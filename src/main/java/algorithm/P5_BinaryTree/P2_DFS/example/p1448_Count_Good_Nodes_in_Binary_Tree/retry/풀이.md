# 분석[비교는 아래, 반환은 위]

1. 문제 : 좋은 노드의 개수를 반환 -> 갯수(합계)를 반환(count)
2. 자료 : 전체 노드
3. 조건 : 
- 좋은 노드 판별 -> 현재 노드의 부모 중에 더 큰 값이 없다.

# 풀이 + 예상동작

1. 자식 노드가 부모보다 높으면 count+1 아니면 그냥 패스
2. 부모중에 더 큰값이 없다 -> 자식하고 부모하고 비교하는 로직 
3. 부모를 내려줘야되나 자식을 올려줘야되나 한다면, 부모를 내리는게 더 편하긴하다. 자식을 올리면 일단 set이 필요함
4. 부모 자식 비교해서 큰값을 내려줍니다. 만약 비교 했을떄 더크면 +1 해서 반환합니다.

# 디버깅(예상과 다르면)

1. 

# 회고(답지와 비교)

1. 위로올라갈지, 아래로 내려갈지
   - max 를 잡아서 내려주는 것도 괜찮아 보이는데
   1. 부모에서 자식 비교하는게 편하긴합니다.
   2. 합칠떄는 자식에서 부모로 해주고 
2. 비교는 아래, 반환은 위
```java
   if (node.val >= maxSoFar) {
   ans += 1;
   }
   return ans;
```

위처럼 구하고 반환하는것도 괜찮네요

https://leetcode.com/problems/count-good-nodes-in-binary-tree/submissions/1755356691