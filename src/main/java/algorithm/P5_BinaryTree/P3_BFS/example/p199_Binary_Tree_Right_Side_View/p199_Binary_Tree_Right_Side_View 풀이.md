# 분석

1. 미지(반환) : 오른쪽에서 봤을때의 트리의 노드의 값 -> 값들 Integer 
2. 자료 : 하나의 이진트리
3. 조건 :
- 맨 오른쪽에 있는 숫자, 그니깐 같은 depth에서 맨 오른쪽에 있는 노드 출력
4. 미지 연산(조상 갱신, 형제 연산, 레벨의 경계) : 
- 맨 오른 쪽에 있는 값인지 어떻게 알지? -> 현재 depth 중 마지막 수만 기록
- 현재 depth에 있는거 다 리스트로 기록하고, 마지막 요소 추가, 리스트에 있는 left, right 큐에 넣는다

# 회고

1. 내풀이
- 어떻게 풀어야 잘푼걸까...
- 지금은 다 따로 저장을 해서, 메모리가 낭비가 됬을 것 같긴하다
- 그리고 배출하는걸 2번 돌아서 시간 복잡도도 딱히 좋지가 않네
- ㄱ이거 여유가 있으면 시간 O(N * m*m)


---
1. 답지
- 문제를 "각 레벨의 가장 오른쪽 노드 찾기
- 위에 prev로 마지막 노드의 val를 기록을 해주네
- 새로 들어온 노드랑 구분하는 방법은 현재 큐 size()로
- O(N * m)
---

1. 어떻게 하면 더 잘 문제를 풀수가 있을깠?
- 현재 depth 중 마지막 수만 기록 -> 이걸 어떻게 답지처럼 생각할 수있을까?
- BFS에서 레벨 경계를 아는 가장 쉬운 방법 = size = queue.size()를 먼저 고정

---
- DFS로도 한번 풀어보자


# 개념 정리

```text
이 때문에 이진 트리 알고리즘 문제에서는 BFS보다 DFS를 사용하는 것이 "더 좋은" 경우가 매우 드뭅니다. 그러나
DFS 구현은 보통 더 적은 코드가 필요하고, 재귀를 사용한다면 구현이 더 쉽기 때문에, BFS/DFS가 중요하지 않은 문
제에서는 대부분의 사람들이 결국 DFS를 사용합니다.

BFS의 주요 단점은 찾고 있는 노드가 트리의 하단에 가까울 경우, 그 하단에 도달하기 위해 모든 레벨을 탐색하는 데 많
은 시간을 낭비하게 된다는 것입니다.
```


내꺼 : https://leetcode.com/problems/binary-tree-right-side-view/submissions/1759497313
답지 : https://leetcode.com/problems/binary-tree-right-side-view/submissions/1759520577