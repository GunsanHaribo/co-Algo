# 풀이규칙
1. 동작하게 30분
2. 개선은 1시간 반

# 유형
1. 유사트리
  - SameTree: “같은 위치에 같은 값” → 구조+값
  - leaf-Similar: “리프 순서만 같으면 OK” → 값만 
  - 대칭 / 거울 / 중심 기준 : “왼쪽과 오른쪽을 짝(pair) 지어 비교
2. 조상 갱신(자식 여러개), 형제 연산, 레벨의 경계, 단조성:node.val 비교

# 분석

1. 미지 : 루트-리프 경로 반환, 경로에 있는 노드갑스이 합니 targetSum과 같은
2. 자료 : 이진트리하나
3. 조건(결과는 역, 기능은 정) : 
- 루트-리프 경로 반환 : 루트에서 리트까지 이동하는기능, 경로 저장하는기능 
- 합이 targetSum인지 확인하고 제출

# 회고

- 풀이 : 
  - https://leetcode.com/problems/path-sum-ii/submissions/1771586801
- 성능 개선 풀이 : sum 조상 갱신
  - https://leetcode.com/problems/path-sum-ii/submissions/1771604790
- 한번 더 개선 풀이
  - DFS = “탐색” + 백트래킹 = “상태 되돌리기” 조합

```text

개선을 시킬떄 어떤 포인트에서 개선을 시켜야될지를 모르겠네
어느 것부터 개선을 시켜야되지 이거 시간 복잡도 부터 생각해야되나?
고민이 되는데, 시간 복잡도 별로 차이가 안 날것 같은데, 흐음.. 이거 어떻게 해봐야되지?

```
```text
3. 중복/불필요한 복사 문제 발견
	•	단순 DFS로 풀면 매번 리스트 복사 발생
	•	또는 visited 배열을 계속 새로 만들게 됨

➡ “매번 새로 만드는 건 낭비 → 공유할 수 없을까?”

⸻

4. “되돌리기” 아이디어 등장
	•	한 경로로 내려갔다가 다시 올라올 때, 이전 상태로 복원해야 함
	•	복사 대신 추가하고, 탐색 끝나면 빼고 돌아오자

➡ 이게 바로 백트래킹의 핵심 사고

```


