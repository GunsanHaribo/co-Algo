# 풀이규칙
1. 동작하게 30분
2. 개선은 1시간 반

# 유형
1. 유사트리(순회 방식)
- 순회 방식
  - 전위: 노드를 방문하는 순간 그 값을 기록하거나 누적해야 하는 경우에 사용. 
    - 예를 들어 경로를 수집하거나 합을 계산할 때는, 자식으로 내려가기 전에 현재 노드를 path/합에 포함시켜야 한다. 
    - (예: Path Sum II, Root-to-Leaf Paths)
  - 후위: 자식들을 다 처리한 결과를 기반으로 부모의 상태를 결정해야 할 때 적합. 
    - 삭제, 높이 계산, 균형 여부 같은 건 반드시 왼쪽·오른쪽 정보를 모은 뒤에만 판단할 수 있다. 
    - (예: Delete Leaves, Tree Depth, Balanced Tree)
  - 중위 : 중위는 BST에서 오름차순 순서
- SameTree: “같은 위치에 같은 값” → 구조+값
- leaf-Similar: “리프 순서만 같으면 OK” → 값만 
- 대칭 / 거울 / 중심 기준 : “왼쪽과 오른쪽을 짝(pair) 지어 비교

2. 조상 갱신(자식 여러개), 형제 연산, 레벨의 경계, 단조성:node.val 비교

---

# 분석

1. 미지 : 가장 긴 지그재그 경로를 반환 -> 지그재그 길이 == 방문한 노드수 -1
2. 자료 : 이진 트리 하나
3. 조건(결과는 역, 기능은 정) :
- 오른쪽, 왼쪽 이렇게 이동을 할 수 있어야함
- 근데 이게 문제가, 전역변수로 저장이 되면 안되고, 매개변수로 넣어줘야되네
- isLeft = true고,  right가 있으면 isLeft = false 하고 +1해서 넣어줍니다.
- isLeft = false고,  left가 있으면 isLeft = true하고 +1해서 넣어줍니다.
- 만약에 right일떄 right가 없으면, 거기서 max를 한번 갱신하는거지
- left일떄 left가 없어도 갱신하는거고 그리고 여기서는 count=0으로 초기화
- 현재 노드에서 오른쪽 갔을떄도 생각해야함

-----

현재 풀이로는 처음부터는 가능한데, 중간에 부분합을 구하는건 불가능함
- 구간합 느낌이 있는데, 투포인터 처럼이걸 어떻게 접목을 하지?
- 백트레킹을 조금 생각해봐야되나 -> 근데 이것도 이문제에서는 똑같을 것 같은데
- 아니면 현재 노드에서 한번 더 생각을 해보게 식을 짜봐야하나? 

# 회고
- 이걸 어떻게 해야하나
- 같은걸 다시도는것도 문제인데 : timeLimit 문제
  - https://leetcode.com/problems/longest-zigzag-path-in-a-binary-tree/submissions/1772189828
  - 현재 왼쪽 걸 계속 두는데
    - 흐음.. 이걸 어떻게 해야되나, 현재 노드의 시점에서도 지그재그를 봐줘야되는데
    - 이러면 중복으로 순회해서 타임 리미트에 걸린다. 좋은 방법 없을까?
-----------------------------------------------------------
그니깐 지금 문제가 사고과정이 얼추 비슷하게는 맞는데
완전 정확하게는 안맞아서 문제인 것 같은데