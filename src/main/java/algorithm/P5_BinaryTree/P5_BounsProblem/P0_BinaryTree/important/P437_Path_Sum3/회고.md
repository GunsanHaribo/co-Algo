# 치트시트(3Q) — 결과만으로 풀 수 있나?

> 결론: **결과만(~이면)**으로는 부족하고, 최소 **3가지 조건**(범위/목표/음수)을 같이 봐야 실수 없이 빠르게 결정됩니다.

## 3Q 분기 (30초 체크)
1) **범위**: 루트→리프인가? 아무 노드 시작 OK인가?
2) **목표**: 존재/리스트 vs **개수** vs **최대(또는 최소/근사)**?
3) **음수**: 값에 음수 포함? (있으면 가지치기/윈도우 금지)

### 결론 매핑
- **루→리 & 존재** → DFS 누적합  
- **루→리 & 리스트** → DFS + 백트래킹  
- **아무 노드 & 개수** → (작은 N) 각 노드 시작 DFS / (큰 N) **Prefix-Sum+HashMap(O(N))**  
- **아무 노드 & 최대** → 후위 DFS + 전역 최대  
- **음수 있음** → 슬라이딩 윈도우/두 포인터 **금지**, Prefix-Sum 선호

## 안전 규칙(반드시)
- 노드값 10^9급이면: 누적합/비교/Map 키 **long**
- 편향 트리/동일값 반복: O(N^2) 가능성 → Prefix-Sum로 스위치

---

## 코드 템플릿(요약)

### A. 각 노드 시작(단순·직관)
```java
int pathSum(TreeNode r, int T){
  return r==null?0 : count(r, T) + pathSum(r.left, T) + pathSum(r.right, T);
}
int count(TreeNode n, long T){
  if(n==null) return 0;
  int c = (n.val==T?1:0);
  return c + count(n.left, T-n.val) + count(n.right, T-n.val);
}
```

### B. Prefix-Sum + HashMap(O(N))
```java
int pathSum(TreeNode root, int target){
  Map<Long,Integer> freq = new HashMap<>();
  freq.put(0L,1);
  return dfs(root, 0L, (long)target, freq);
}
int dfs(TreeNode n, long sum, long T, Map<Long,Integer> f){
  if(n==null) return 0;
  sum += n.val;
  int ans = f.getOrDefault(sum - T, 0);
  f.put(sum, f.getOrDefault(sum,0)+1);
  ans += dfs(n.left, sum, T, f);
  ans += dfs(n.right, sum, T, f);
  f.put(sum, f.get(sum)-1); // backtrack
  return ans;
}
```

---

## 왜 결과만으로는 안 되나?
같은 “개수”라도 **범위(루→리 vs 아무 노드)**·**음수 여부**에 따라 풀이가 달라짐.
→ 그러니 최소 3Q(범위·목표·음수)만 체크하고 위 매핑에 꽂아라. 그럼 “외우기”가 아니라 “판별”이 된다.

# 풀이규칙

1. 동작하게 30분
2. 개선은 1시간 반

# 유형

1. 유사트리(순회 방식)

- 순회 방식
    - 전위: 노드를 방문하는 순간 그 값을 기록하거나 누적해야 하는 경우에 사용.
        - 예를 들어 경로를 수집하거나 합을 계산할 때는, 자식으로 내려가기 전에 현재 노드를 path/합에 포함시켜야 한다.
        - (예: Path Sum II, Root-to-Leaf Paths)
    - 후위: 자식들을 다 처리한 결과를 기반으로 부모의 상태를 결정해야 할 때 적합.
        - 삭제, 높이 계산, 균형 여부 같은 건 반드시 왼쪽·오른쪽 정보를 모은 뒤에만 판단할 수 있다.
        - (예: Delete Leaves, Tree Depth, Balanced Tree)
    - 중위 : 중위는 BST에서 오름차순 순서
- SameTree: “같은 위치에 같은 값” → 구조+값
- leaf-Similar: “리프 순서만 같으면 OK” → 값만
- 대칭 / 거울 / 중심 기준 : “왼쪽과 오른쪽을 짝(pair) 지어 비교

2. 조상 갱신(자식 여러개), 형제 연산, 레벨의 경계, 단조성:node.val 비교

---

# 분석

1. 미지 : 경로값의 합이 targetSum과 같은 경로의 갯수 -> count
2. 자료 : 이진트리하나 targetSum
3. 조건(결과와 문제를 어떻게 엮을 수 있을까?, 어떻게하면 결과로만 역으로 가지않지? 역으로 가면 풀리긴 풀리는데 best 풀이가 안나와 시간도 오래걸리고) :

- 경로 값의 합이 targetSum과 같은 경로의 갯수를 구합니다.
- 어딘가 빠지고 들어가야되는게 있을 것 같긴하네요, 전체를 다 기록할 수는 없다.
- 필요한기능
    - count 해주는 기능
    - path 기록해주는 기능, 흐음.. 잠시만 이거 난 왜 투포인터가 보이지?
        - 큐로 유지는 해 대신에 다음 수를 넣고 targetSum보다 크다 그러면 앞에거뺴
        - 작다 그러면 그냥 진행
        - 같다 그러면 count++
- 큐를 그러면 시작할떄 넣어줘야겠네, +nextSum도 같이 진행하자, 꺼내서 계산하기 귀찮으니깐



# 회고

## 1차 풀이 : 말도 안되는 풀이

- 트리 순회할떄는 백트래킹은 필수로 해야겠네, 살짝 이렇게만 보면 헷갈린다.
- 원하는대로가 뭔데? 백트래킹이야?, 투포인터인데 포인터는 유지가 안되니깐 큐로 했는데 엣지케이스가 너무 많은데?

-----------------------------------------------------------------------

- 현재 로직 진행

1. 다음 노드로 진행할때 큐에 데이터를 넣음
2. nextSum으로 현재 합 갱신
3. targetSum과 같은 숫자가 들어왔을때 먼저들어온 노드를 날리면서 count
4. nextSum이 targetSum일떄 count++
5. targetSum이 양수면 내려가면서, 합이 특정수보다 크면 먼저들어간 수를 뺴줍니다.
6. targetSum이 음수면 내려가면서, 합이 특성 수보다 작으면 뺴줍니다.
7. 다음 진행 -> left, right

-----------------------

- 이전 풀이에서 뭐가 문제일까?, 왜틀리지 그리고, 어떻게 하면 주어진 케이스 말고 다른 케이스들도 맞출 수 있을까?
- 엣지 케이스들을 어떻게 탈출하게 만들 수 있지?
- 이 루프를 탈출하게 만들려면 뭐가 선행되어야할까?, 나올 수 있는 경우의 수를 다 적어야하나?
- 예제에 맞추면 진짜 예제만 통과하는게 문제니깐, 이걸 어떻게 해결할 수 있을까?

```text
- 필요한기능
    - count 해주는 기능
    - path 기록해주는 기능, 흐음.. 잠시만 이거 난 왜 투포인터가 보이지?
        - 큐로 유지는 해 대신에 다음 수를 넣고 targetSum보다 크다 그러면 앞에거뺴 
        - 작다 그러면 그냥 진행
        - 같다 그러면 count++
- 큐를 그러면 시작할떄 넣어줘야겠네, +nextSum도 같이 진행하자, 꺼내서 계산하기 귀찮으니깐
```

- 이 사고가 맞는 생각이였나? 기능을 조합해주다가 어떤 문제가 발생한거지?
- 어떤 부분에서 놓친거지? 내 생각은 아래 방향으로 진행을 아래로 가면서 먼저들어간걸 뺴준다로 잘못이해한것 같은데

## 2차 풀이 : 다시 풀기

- 일단 다 넣다가, targe이 넘어버리면 뺴야하나, 아 잠시만,, -3 이런것 때문에 마음대로 뺄 수도 없는데
- 일단 다 넣어봐그러면, 넣고나서, 흐음.. 이걸 어떻게 해야하나..
- 다 넣은다음에 올라갈떄 앞에서부터 뺴야하나?, 위에꺼를 뺴보단가, 앞에꺼를 뺴야되는데, 둘다 뺴자 이렇게 할거면 Deque로 넣고
- 이렇게 하고 targetSum과 같으면 ++
- +-는 백트래킹으로 진행합니다.

---------------------------------------------------

- 10 5 2 1 -> 5 2 1 : 위로 올라가면서 먼저들어간거 빼줘야함
- 10 5 2 -> 아래로 내려가면서 해당 숫자가 있는지 확인
- 5, 3 -> 10, 5, 3 이나 10 ,5, 3,3 이나 -> 내려가면서 위에걸 제거를 했던가 아니면 다 내려가고나서 올라갈때 3과 10을 동시에 제거를 했던가
- 하나 확실한건, 올라가면서 현재노드를 제거하는 건 있어야함
- 그럼 뭐 올라가면서 하나씩 뺴줘야하나? 일단 확실한건 밑으로 내리면서하던 올리면서하던, 이미 들어간 노드를 뺴주는 건 있어야 하긴하는데
- 그리고 노드마다 추가적으로 Path를 만드는거는 진짜 완전 탐색이라 탐색 비용이 많이 클듯

----------------------------------

- 그냥 내려가면서는 계산 안하고 올라가면서만 계산하기(이유: 겹치니깐) + 노드가 다있는 상태에서 계산을 하는게 더 편함
- 10, 5, 3, 3 (전위)/ 5,3,3 | 3, 3 | 3
- 10, 5, 3/(후위) ->  5, 3 | 3  (이거 너무 완전탐색인데, 이래도 되나?, 이래도 되는 경우를 찾아보자)
- 10, 5 / -> 10 | 5
- 10

------------------------------------

- 10, 5, 2, 1
- 10, 5, 2 -> 5, 2 | 2
- 10, 5 -> 5
- 10

------------------------------------

- 예제로 한번 이렇게 시뮬레이션을 해보고 들어가야하나?, 아니면 흐음.. 고민이 되는데
- 로직이 확정이 됬다. 이걸 어떻게 알지? 어느정도 까지 해봐야 코드에 손을 대지?
- 이렇게 다해보면 시간이 많이 들긴할텐데
- 내려갈떄는 전위, 올라갈떄는 후위? 이렇게 해도되나?

-------------------------------------

- 아 잠시만, 중복되는데 이게? left하고 right 둘다 있어가지고, left할떄만 해야되나?
- 아니면 그냥 전위 순회하면서 앞에꺼 다 뺴버릴까...
- 아 이게 케이스 생각하기가 개빡센
- 시간초과
    - https://leetcode.com/problems/path-sum-iii/submissions/1773380919
    - 아니 순회하는데 그러면 시간초과가 안나게 할 수도 있나? 화가나네 정말

----------------------------------------------------

- 순회할때 사이에 로직을 어디에 넣을 건지도 고려해야 합니다.
- 순회 종류에 따른 전략도 생각해야 합니다.

## 3차 풀이 : 시간초과

- 시간초과의 문제는 무엇일까....스트림을 한번 줄여볼까.. -> 스트린하고는 관계없
- 합을 계속 구해주는게 문제인 것 같은데 -> 다 순회하는데
- N(원소갯수) * H/2(그떄 트리 높이만큼 조합) = N * (logN/2) -> 문제가 되나 이게?
- 미리 합을 계산 -> N(원소 갯수)*K(큐에서 뺼 경우, 합에서 뺄 경우 + 더하는 경우) -> N * K
- 감소는 하는데 그러면 이 합을 어디에 넣어두지?, 여기서는 뒤에서 뺴줘서 넣기가 애매하긴한데, 앞에서 그냥 넣는 용도로 활용
- 시간 제한은 해결  
  - https://leetcode.com/problems/path-sum-iii/submissions/1773409104
  - 대신 뭐가 하나 걸리는데 범위 초과 문제인듯함


## 4차 풀이 : capacity
- 터지는거 맞네, 참 교모하게 해 놓았네
- 이것도 사전에 대비 해야함
- https://leetcode.com/problems/path-sum-iii/submissions/1773413959


## 모범 풀이
- DFS로도 풀었네, SUM 가져와라 이런식으로, 이렇게 가야되는데 지금 내 방법은 너무 호흡이 길어
- 이렇게 간단하게 푸는게 맞다고 생각이 들긴한다. 어떻게 이렇게 생각할 수 있었나?
- targetSum - node.val 이게 핵심이네, 현재 노드값을 뺸값이 하위노드에 있는가? + 현재노드
- 

## 재발 방지

1. 처음 문제 봤을때 생각하는 법
- 결과 ~이면, 으로 가고 가능한 여러가지 중에 가장 구현하기 쉬운것?을 채택합니다.
- 현재 결과~이면으로 해서 풀긴 풀었음나 살짝 복잡하고 시간복잡도가 안좋은 풀이가 나왔는데
- 조건을 보고 골라야되는게 맞긴한데, 조건을 봤더니 이렇게 나오더라~
- 결과만 보고는 판단이 힘들어, 풀이가 다양해지기도 하고
```text
## 트리 경로 문제 초간단 분기

1) 경로 범위
- 루트→리프: 존재 → DFS 누적합 / 리스트 → DFS+백트래킹

2) 아무 노드 시작 OK
- 개수: (작은 N) 각 노드 시작 DFS / (큰 N) Prefix-Sum+HashMap(O(N))
- 최대: 후위 DFS + 전역 최대

3) 값 특성
- 음수 있음 → 가지치기 금지(윈도우 X) → Prefix-Sum 선호
- 모두 양수 → target 넘으면 중단(가지치기) 가능

4) BST면
- 중위 단조성 활용(투포인터/양방향 스택/이분)

5) 안전 규칙
- 값 10^9대 → 합/맵키 long
- 편향 트리/동일값 반복 → O(N^2) 경계 → Prefix-Sum로 스위치
```

2. 시간 초과가 날것 같을떄 생각하는 법
- 뭔가 노드를 방문했을 떄마다 다 탐색하는 로직은 비추
3. Integer 용량 초과 식별법
- 합을 구하는 풀이에서 원소가 10^9일대 
4. 후에 회고 하는 법
- 이건 어떻게 해야하나.


- 타고 간다음에 결과 나열하고, 기능 추출을 해야되는건 맞나?
- 모범 풀이만 봤을때는 흐음.. 내려가면서 확인을 한다. 맞는 말이긴하긴한데 
- 각 예시에 대한 케이스들의 교집합을 보고 어떤 흐름이 더 좋은지만 생각하면 될 것 같은데



```text
# 치트시트(3Q) — 결과만으로 풀 수 있나?

> 결론: **결과만(~이면)**으로는 부족하고, 최소 **3가지 조건**(범위/목표/음수)을 같이 봐야 실수 없이 빠르게 결정됩니다.

## 3Q 분기 (30초 체크)
1) **범위**: 루트→리프인가? 아무 노드 시작 OK인가?
2) **목표**: 존재/리스트 vs **개수** vs **최대(또는 최소/근사)**?
3) **음수**: 값에 음수 포함? (있으면 가지치기/윈도우 금지)

### 결론 매핑
- **루→리 & 존재** → DFS 누적합  
- **루→리 & 리스트** → DFS + 백트래킹  
- **아무 노드 & 개수** → (작은 N) 각 노드 시작 DFS / (큰 N) **Prefix-Sum+HashMap(O(N))**  
- **아무 노드 & 최대** → 후위 DFS + 전역 최대  
- **음수 있음** → 슬라이딩 윈도우/두 포인터 **금지**, Prefix-Sum 선호

## 안전 규칙(반드시)
- 노드값 10^9급이면: 누적합/비교/Map 키 **long**
- 편향 트리/동일값 반복: O(N^2) 가능성 → Prefix-Sum로 스위치

---

## 코드 템플릿(요약)

### A. 각 노드 시작(단순·직관)
```java
int pathSum(TreeNode r, int T){
  return r==null?0 : count(r, T) + pathSum(r.left, T) + pathSum(r.right, T);
}
int count(TreeNode n, long T){
  if(n==null) return 0;
  int c = (n.val==T?1:0);
  return c + count(n.left, T-n.val) + count(n.right, T-n.val);
}
```

### B. Prefix-Sum + HashMap(O(N))
```java
int pathSum(TreeNode root, int target){
  Map<Long,Integer> freq = new HashMap<>();
  freq.put(0L,1);
  return dfs(root, 0L, (long)target, freq);
}
int dfs(TreeNode n, long sum, long T, Map<Long,Integer> f){
  if(n==null) return 0;
  sum += n.val;
  int ans = f.getOrDefault(sum - T, 0);
  f.put(sum, f.getOrDefault(sum,0)+1);
  ans += dfs(n.left, sum, T, f);
  ans += dfs(n.right, sum, T, f);
  f.put(sum, f.get(sum)-1); // backtrack
  return ans;
}
```

---

## 왜 결과만으로는 안 되나?
같은 “개수”라도 **범위(루→리 vs 아무 노드)**·**음수 여부**에 따라 풀이가 달라짐.
→ 그러니 최소 3Q(범위·목표·음수)만 체크하고 위 매핑에 꽂아라. 그럼 “외우기”가 아니라 “판별”이 된다.

# 풀이규칙

1. 동작하게 30분
2. 개선은 1시간 반

# 유형

1. 유사트리(순회 방식)

- 순회 방식
    - 전위: 노드를 방문하는 순간 그 값을 기록하거나 누적해야 하는 경우에 사용.
        - 예를 들어 경로를 수집하거나 합을 계산할 때는, 자식으로 내려가기 전에 현재 노드를 path/합에 포함시켜야 한다.
        - (예: Path Sum II, Root-to-Leaf Paths)
    - 후위: 자식들을 다 처리한 결과를 기반으로 부모의 상태를 결정해야 할 때 적합.
        - 삭제, 높이 계산, 균형 여부 같은 건 반드시 왼쪽·오른쪽 정보를 모은 뒤에만 판단할 수 있다.
        - (예: Delete Leaves, Tree Depth, Balanced Tree)
    - 중위 : 중위는 BST에서 오름차순 순서
- SameTree: “같은 위치에 같은 값” → 구조+값
- leaf-Similar: “리프 순서만 같으면 OK” → 값만
- 대칭 / 거울 / 중심 기준 : “왼쪽과 오른쪽을 짝(pair) 지어 비교

2. 조상 갱신(자식 여러개), 형제 연산, 레벨의 경계, 단조성:node.val 비교

---

# 분석

1. 미지 : 경로값의 합이 targetSum과 같은 경로의 갯수 -> count
2. 자료 : 이진트리하나 targetSum
3. 조건(문제가 ~이면) :

- 경로 값의 합이 targetSum과 같은 경로의 갯수를 구합니다.
- 어딘가 빠지고 들어가야되는게 있을 것 같긴하네요, 전체를 다 기록할 수는 없다.
- 필요한기능
    - count 해주는 기능
    - path 기록해주는 기능, 흐음.. 잠시만 이거 난 왜 투포인터가 보이지?
        - 큐로 유지는 해 대신에 다음 수를 넣고 targetSum보다 크다 그러면 앞에거뺴
        - 작다 그러면 그냥 진행
        - 같다 그러면 count++
- 큐를 그러면 시작할떄 넣어줘야겠네, +nextSum도 같이 진행하자, 꺼내서 계산하기 귀찮으니깐

# 회고

## 1차 풀이 : 말도 안되는 풀이

- 트리 순회할떄는 백트래킹은 필수로 해야겠네, 살짝 이렇게만 보면 헷갈린다.
- 원하는대로가 뭔데? 백트래킹이야?, 투포인터인데 포인터는 유지가 안되니깐 큐로 했는데 엣지케이스가 너무 많은데?

-----------------------------------------------------------------------

- 현재 로직 진행

1. 다음 노드로 진행할때 큐에 데이터를 넣음
2. nextSum으로 현재 합 갱신
3. targetSum과 같은 숫자가 들어왔을때 먼저들어온 노드를 날리면서 count
4. nextSum이 targetSum일떄 count++
5. targetSum이 양수면 내려가면서, 합이 특정수보다 크면 먼저들어간 수를 뺴줍니다.
6. targetSum이 음수면 내려가면서, 합이 특성 수보다 작으면 뺴줍니다.
7. 다음 진행 -> left, right

-----------------------

- 이전 풀이에서 뭐가 문제일까?, 왜틀리지 그리고, 어떻게 하면 주어진 케이스 말고 다른 케이스들도 맞출 수 있을까?
- 엣지 케이스들을 어떻게 탈출하게 만들 수 있지?
- 이 루프를 탈출하게 만들려면 뭐가 선행되어야할까?, 나올 수 있는 경우의 수를 다 적어야하나?
- 예제에 맞추면 진짜 예제만 통과하는게 문제니깐, 이걸 어떻게 해결할 수 있을까?

```text
- 필요한기능
    - count 해주는 기능
    - path 기록해주는 기능, 흐음.. 잠시만 이거 난 왜 투포인터가 보이지?
        - 큐로 유지는 해 대신에 다음 수를 넣고 targetSum보다 크다 그러면 앞에거뺴 
        - 작다 그러면 그냥 진행
        - 같다 그러면 count++
- 큐를 그러면 시작할떄 넣어줘야겠네, +nextSum도 같이 진행하자, 꺼내서 계산하기 귀찮으니깐
```

- 이 사고가 맞는 생각이였나? 기능을 조합해주다가 어떤 문제가 발생한거지?
- 어떤 부분에서 놓친거지? 내 생각은 아래 방향으로 진행을 아래로 가면서 먼저들어간걸 뺴준다로 잘못이해한것 같은데

## 2차 풀이 : 다시 풀기

- 일단 다 넣다가, targe이 넘어버리면 뺴야하나, 아 잠시만,, -3 이런것 때문에 마음대로 뺄 수도 없는데
- 일단 다 넣어봐그러면, 넣고나서, 흐음.. 이걸 어떻게 해야하나..
- 다 넣은다음에 올라갈떄 앞에서부터 뺴야하나?, 위에꺼를 뺴보단가, 앞에꺼를 뺴야되는데, 둘다 뺴자 이렇게 할거면 Deque로 넣고
- 이렇게 하고 targetSum과 같으면 ++
- +-는 백트래킹으로 진행합니다.

---------------------------------------------------

- 10 5 2 1 -> 5 2 1 : 위로 올라가면서 먼저들어간거 빼줘야함
- 10 5 2 -> 아래로 내려가면서 해당 숫자가 있는지 확인
- 5, 3 -> 10, 5, 3 이나 10 ,5, 3,3 이나 -> 내려가면서 위에걸 제거를 했던가 아니면 다 내려가고나서 올라갈때 3과 10을 동시에 제거를 했던가
- 하나 확실한건, 올라가면서 현재노드를 제거하는 건 있어야함
- 그럼 뭐 올라가면서 하나씩 뺴줘야하나? 일단 확실한건 밑으로 내리면서하던 올리면서하던, 이미 들어간 노드를 뺴주는 건 있어야 하긴하는데
- 그리고 노드마다 추가적으로 Path를 만드는거는 진짜 완전 탐색이라 탐색 비용이 많이 클듯

----------------------------------

- 그냥 내려가면서는 계산 안하고 올라가면서만 계산하기(이유: 겹치니깐) + 노드가 다있는 상태에서 계산을 하는게 더 편함
- 10, 5, 3, 3 (전위)/ 5,3,3 | 3, 3 | 3
- 10, 5, 3/(후위) ->  5, 3 | 3  (이거 너무 완전탐색인데, 이래도 되나?, 이래도 되는 경우를 찾아보자)
- 10, 5 / -> 10 | 5
- 10

------------------------------------

- 10, 5, 2, 1
- 10, 5, 2 -> 5, 2 | 2
- 10, 5 -> 5
- 10

------------------------------------

- 예제로 한번 이렇게 시뮬레이션을 해보고 들어가야하나?, 아니면 흐음.. 고민이 되는데
- 로직이 확정이 됬다. 이걸 어떻게 알지? 어느정도 까지 해봐야 코드에 손을 대지?
- 이렇게 다해보면 시간이 많이 들긴할텐데
- 내려갈떄는 전위, 올라갈떄는 후위? 이렇게 해도되나?

-------------------------------------

- 아 잠시만, 중복되는데 이게? left하고 right 둘다 있어가지고, left할떄만 해야되나?
- 아니면 그냥 전위 순회하면서 앞에꺼 다 뺴버릴까...
- 아 이게 케이스 생각하기가 개빡센
- 시간초과
    - https://leetcode.com/problems/path-sum-iii/submissions/1773380919
    - 아니 순회하는데 그러면 시간초과가 안나게 할 수도 있나? 화가나네 정말

----------------------------------------------------

- 순회할때 사이에 로직을 어디에 넣을 건지도 고려해야 합니다.
- 순회 종류에 따른 전략도 생각해야 합니다.

## 3차 풀이 : 시간초과

- 시간초과의 문제는 무엇일까....스트림을 한번 줄여볼까.. -> 스트린하고는 관계없
- 합을 계속 구해주는게 문제인 것 같은데 -> 다 순회하는데
- N(원소갯수) * H/2(그떄 트리 높이만큼 조합) = N * (logN/2) -> 문제가 되나 이게?
- 미리 합을 계산 -> N(원소 갯수)*K(큐에서 뺼 경우, 합에서 뺄 경우 + 더하는 경우) -> N * K
- 감소는 하는데 그러면 이 합을 어디에 넣어두지?, 여기서는 뒤에서 뺴줘서 넣기가 애매하긴한데, 앞에서 그냥 넣는 용도로 활용
- 시간 제한은 해결
    - https://leetcode.com/problems/path-sum-iii/submissions/1773409104
    - 대신 뭐가 하나 걸리는데 범위 초과 문제인듯함


## 4차 풀이 : capacity
- 터지는거 맞네, 참 교모하게 해 놓았네
- 이것도 사전에 대비 해야함
- https://leetcode.com/problems/path-sum-iii/submissions/1773413959


## 모범 풀이
- DFS로도 풀었네, SUM 가져와라 이런식으로, 이렇게 가야되는데 지금 내 방법은 너무 호흡이 길어
- 이렇게 간단하게 푸는게 맞다고 생각이 들긴한다. 어떻게 이렇게 생각할 수 있었나?
- targetSum - node.val 이게 핵심이네, 현재 노드값을 뺸값이 하위노드에 있는가? + 현재노드
-

## 재발 방지

1. 처음 문제 봤을때 생각하는 법
- 결과 ~이면, 으로 가고 가능한 여러가지 중에 가장 구현하기 쉬운것?을 채택합니다.
- 현재 결과~이면으로 해서 풀긴 풀었음나 살짝 복잡하고 시간복잡도가 안좋은 풀이가 나왔는데
- 조건을 보고 골라야되는게 맞긴한데, 조건을 봤더니 이렇게 나오더라~
- 결과만 보고는 판단이 힘들어, 풀이가 다양해지기도 하고
```text
## 트리 경로 문제 초간단 분기

1) 경로 범위
- 루트→리프: 존재 → DFS 누적합 / 리스트 → DFS+백트래킹

2) 아무 노드 시작 OK
- 개수: (작은 N) 각 노드 시작 DFS / (큰 N) Prefix-Sum+HashMap(O(N))
- 최대: 후위 DFS + 전역 최대

3) 값 특성
- 음수 있음 → 가지치기 금지(윈도우 X) → Prefix-Sum 선호
- 모두 양수 → target 넘으면 중단(가지치기) 가능

4) BST면
- 중위 단조성 활용(투포인터/양방향 스택/이분)

5) 안전 규칙
- 값 10^9대 → 합/맵키 long
- 편향 트리/동일값 반복 → O(N^2) 경계 → Prefix-Sum로 스위치
```

2. 시간 초과가 날것 같을떄 생각하는 법
- 뭔가 노드를 방문했을 떄마다 다 탐색하는 로직은 비추
3. Integer 용량 초과 식별법
- 합을 구하는 풀이에서 원소가 10^9일대
4. 후에 회고 하는 법
- 이건 어떻게 해야하나.

#### 축약 

```text
1.	경로 범위

•	루트→리프만이면 → DFS 누적합 (리스트면 백트래킹)
•	아무 노드 시작 OK면 → 전역 탐색 필요

2.	목표 타입

•	개수면 → (작은 N) 각 노드 시작 / (큰 N 또는 느려 보이면) Prefix-Sum+HashMap(O(N))
•	존재면 → DFS 중 발견 즉시 반환
•	최대면 → 후위 DFS(+전역 최대 갱신)
```
-------------------------------------


# 핵심은 부분구간 합을 어떻게 구할까 아닌가?
이전에는 prefix같은 것만 했다면, 그리고 이게 조건이 안맞는것 같은데
이런 유형이 나온다면 어떻게 해야할지 생각하는게,... 
그니깐 경로값의 합이 부분합인지 아니면 그냥 처음부터 시작하는건지 그거의 문제인 것 같은필