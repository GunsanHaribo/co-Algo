# 풀이규칙

1. 동작하게 30분
2. 개선은 1시간 반

# 유형

1. 유사트리(순회 방식)

- 순회 방식
    - 전위: 노드를 방문하는 순간 그 값을 기록하거나 누적해야 하는 경우에 사용.
        - 예를 들어 경로를 수집하거나 합을 계산할 때는, 자식으로 내려가기 전에 현재 노드를 path/합에 포함시켜야 한다.
        - (예: Path Sum II, Root-to-Leaf Paths)
    - 후위: 자식들을 다 처리한 결과를 기반으로 부모의 상태를 결정해야 할 때 적합.
        - 삭제, 높이 계산, 균형 여부 같은 건 반드시 왼쪽·오른쪽 정보를 모은 뒤에만 판단할 수 있다.
        - (예: Delete Leaves, Tree Depth, Balanced Tree)
    - 중위 : 중위는 BST에서 오름차순 순서
- SameTree: “같은 위치에 같은 값” → 구조+값
- leaf-Similar: “리프 순서만 같으면 OK” → 값만
- 대칭 / 거울 / 중심 기준 : “왼쪽과 오른쪽을 짝(pair) 지어 비교

2. 조상 갱신(자식 여러개), 형제 연산, 레벨의 경계, 단조성:node.val 비교

---

# 분석

1. 미지 : 경로값의 합이 targetSum과 같은 경로의 갯수 -> count
2. 자료 : 이진트리하나 targetSum
3. 조건(~이면) :

- 경로 값의 합이 targetSum과 같은 경로의 갯수를 구합니다.
- 어딘가 빠지고 들어가야되는게 있을 것 같긴하네요, 전체를 다 기록할 수는 없다.
- 필요한기능
    - count 해주는 기능
    - path 기록해주는 기능, 흐음.. 잠시만 이거 난 왜 투포인터가 보이지?
        - 큐로 유지는 해 대신에 다음 수를 넣고 targetSum보다 크다 그러면 앞에거뺴
        - 작다 그러면 그냥 진행
        - 같다 그러면 count++
- 큐를 그러면 시작할떄 넣어줘야겠네, +nextSum도 같이 진행하자, 꺼내서 계산하기 귀찮으니깐

# 회고

## 1차 풀이

- 트리 순회할떄는 백트래킹은 필수로 해야겠네, 살짝 이렇게만 보면 헷갈린다.
- 원하는대로가 뭔데? 백트래킹이야?, 투포인터인데 포인터는 유지가 안되니깐 큐로 했는데 엣지케이스가 너무 많은데?

-----------------------------------------------------------------------

- 현재 로직 진행

1. 다음 노드로 진행할때 큐에 데이터를 넣음
2. nextSum으로 현재 합 갱신
3. targetSum과 같은 숫자가 들어왔을때 먼저들어온 노드를 날리면서 count
4. nextSum이 targetSum일떄 count++
5. targetSum이 양수면 내려가면서, 합이 특정수보다 크면 먼저들어간 수를 뺴줍니다.
6. targetSum이 음수면 내려가면서, 합이 특성 수보다 작으면 뺴줍니다.
7. 다음 진행 -> left, right

-----------------------

- 이전 풀이에서 뭐가 문제일까?, 왜틀리지 그리고, 어떻게 하면 주어진 케이스 말고 다른 케이스들도 맞출 수 있을까?
- 엣지 케이스들을 어떻게 탈출하게 만들 수 있지?
- 이 루프를 탈출하게 만들려면 뭐가 선행되어야할까?, 나올 수 있는 경우의 수를 다 적어야하나?
- 예제에 맞추면 진짜 예제만 통과하는게 문제니깐, 이걸 어떻게 해결할 수 있을까?

```text
- 필요한기능
    - count 해주는 기능
    - path 기록해주는 기능, 흐음.. 잠시만 이거 난 왜 투포인터가 보이지?
        - 큐로 유지는 해 대신에 다음 수를 넣고 targetSum보다 크다 그러면 앞에거뺴 
        - 작다 그러면 그냥 진행
        - 같다 그러면 count++
- 큐를 그러면 시작할떄 넣어줘야겠네, +nextSum도 같이 진행하자, 꺼내서 계산하기 귀찮으니깐
```

- 이 사고가 맞는 생각이였나? 기능을 조합해주다가 어떤 문제가 발생한거지?
- 어떤 부분에서 놓친거지? 내 생각은 아래 방향으로 진행을 아래로 가면서 먼저들어간걸 뺴준다로 잘못이해한것 같은데

## 2차 풀이

- 일단 다 넣다가, targe이 넘어버리면 뺴야하나, 아 잠시만,, -3 이런것 때문에 마음대로 뺄 수도 없는데
- 일단 다 넣어봐그러면, 넣고나서, 흐음.. 이걸 어떻게 해야하나..
- 다 넣은다음에 올라갈떄 앞에서부터 뺴야하나?, 위에꺼를 뺴보단가, 앞에꺼를 뺴야되는데, 둘다 뺴자 이렇게 할거면 Deque로 넣고
- 이렇게 하고 targetSum과 같으면 ++
- +-는 백트래킹으로 진행합니다.

---------------------------------------------------

- 10 5 2 1 -> 5 2 1 : 위로 올라가면서 먼저들어간거 빼줘야함
- 10 5 2 -> 아래로 내려가면서 해당 숫자가 있는지 확인
- 5, 3 -> 10, 5, 3 이나 10 ,5, 3,3 이나 -> 내려가면서 위에걸 제거를 했던가 아니면 다 내려가고나서 올라갈때 3과 10을 동시에 제거를 했던가
- 하나 확실한건, 올라가면서 현재노드를 제거하는 건 있어야함
- 그럼 뭐 올라가면서 하나씩 뺴줘야하나? 일단 확실한건 밑으로 내리면서하던 올리면서하던, 이미 들어간 노드를 뺴주는 건 있어야 하긴하는데
- 그리고 노드마다 추가적으로 Path를 만드는거는 진짜 완전 탐색이라 탐색 비용이 많이 클듯

----------------------------------

- 그냥 내려가면서는 계산 안하고 올라가면서만 계산하기(이유: 겹치니깐) + 노드가 다있는 상태에서 계산을 하는게 더 편함
- 10, 5, 3, 3 (전위)/ 5,3,3 | 3, 3 | 3
- 10, 5, 3/(후위) ->  5, 3 | 3  (이거 너무 완전탐색인데, 이래도 되나?, 이래도 되는 경우를 찾아보자)
- 10, 5 / -> 10 | 5
- 10

------------------------------------

- 10, 5, 2, 1
- 10, 5, 2 -> 5, 2 | 2
- 10, 5 -> 5
- 10

------------------------------------

- 예제로 한번 이렇게 시뮬레이션을 해보고 들어가야하나?, 아니면 흐음.. 고민이 되는데
- 로직이 확정이 됬다. 이걸 어떻게 알지? 어느정도 까지 해봐야 코드에 손을 대지?
- 이렇게 다해보면 시간이 많이 들긴할텐데
- 내려갈떄는 전위, 올라갈떄는 후위? 이렇게 해도되나?

-------------------------------------

- 아 잠시만, 중복되는데 이게? left하고 right 둘다 있어가지고, left할떄만 해야되나?
- 아니면 그냥 전위 순회하면서 앞에꺼 다 뺴버릴까...
- 아 이게 케이스 생각하기가 개빡센
- 시간초과
    - https://leetcode.com/problems/path-sum-iii/submissions/1773380919
    - 아니 순회하는데 그러면 시간초과가 안나게 할 수도 있나? 화가나네 정말

----------------------------------------------------

- 순회할때 사이에 로직을 어디에 넣을 건지도 고려해야 합니다.
- 순회 종류에 따른 전략도 생각해야 합니다.

## 3차 풀이

- 시간초과의 문제는 무엇일까....스트림을 한번 줄여볼까.. -> 스트린하고는 관계없
- 합을 계속 구해주는게 문제인 것 같은데 -> 다 순회하는데
- N(원소갯수) * H/2(그떄 트리 높이만큼 조합) = N * (logN/2) -> 문제가 되나 이게?
- 미리 합을 계산 -> N(원소 갯수)*K(큐에서 뺼 경우, 합에서 뺄 경우 + 더하는 경우) -> N * K
- 감소는 하는데 그러면 이 합을 어디에 넣어두지?, 여기서는 뒤에서 뺴줘서 넣기가 애매하긴한데, 앞에서 그냥 넣는 용도로 활용
- 시간 제한은 해결  
  - https://leetcode.com/problems/path-sum-iii/submissions/1773409104
  - 대신 뭐가 하나 걸리는데 범위 초과 문제인듯함


## 4차 풀이
- 터지는거 맞네, 참 교모하게 해 놓았네
- 이것도 사전에 대비 해야함
- https://leetcode.com/problems/path-sum-iii/submissions/1773413959
- 이야.. 이거 그냥 아작이 났는데 ㅋㅋㅋㅋㅋㅋㅋㅋ


## 재발 방지
- 제발 방지를 위해서 어떤 행동을 해야될까
- 나름 잘 풀었는데, 케이스 적어가면서 -> 이걸 적으면서 놓칠 수도 있고 결과로 타고 올라가야되는건 맞다
- 타고 간다음에 결과 나열하고, 기능 추출을 해야되는건 맞아
- 아니..? 기능추출하는데 굳이 앞에서 부터 들어갈 필요가 있나? 
- 각 예시에 대한 케이스들의 교집합을 보고 어떤 흐름이 더 좋은지만 생각하면 될 것 같은데


## 모범 풀이
- Map 쓰는데? ㅋㅋㅋㅋ아오...