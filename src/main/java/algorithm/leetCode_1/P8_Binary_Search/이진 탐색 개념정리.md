# 개념 정리

이진 탐색(Binary Search) 은

“정렬된 탐색 공간에서, 원하는 값을 찾기 위해 절반씩 범위를 줄여나가는 알고리즘”

## 2️⃣ 작동 원리
1. `left = 0`, `right = n - 1` (탐색 구간의 시작/끝)
2. `mid = (left + right) / 2` 로 중간 지점 계산
    - Java/C++에서는 `left + (right - left)/2` 로 오버플로 방지
3. `arr[mid]` 비교:
    - `arr[mid] == x` → 찾음 ✅
    - `arr[mid] > x` → 오른쪽 절반 버림 (`right = mid - 1`)
    - `arr[mid] < x` → 왼쪽 절반 버림 (`left = mid + 1`)
4. 반복하다가 찾지 못하면 → `left`는 삽입 가능한 인덱스 위치


## 4️⃣ 구현 템플릿 (기본형, 중복 없는 경우)
```text
public int binarySearch(int[] arr, int target) {
    int left = 0, right = arr.length - 1;
    while (left <= right) {  -> 탐색 종료 조건
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) return mid;
        if (arr[mid] > target) right = mid - 1;
        else left = mid + 1;
        }
        // 못 찾은 경우 → left는 삽입 위치
        return left;
    }
```

5️⃣ 중복 요소가 있는 경우 (변형 버전)
🔹 왼쪽 경계(Leftmost index) 찾기
```text
public int lowerBound(int[] arr, int target) {
    int left = 0, right = arr.length;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] >= target)
            right = mid;
        else
            left = mid + 1;
    }
    return left;
}
```
🔹 오른쪽 경계(Rightmost insertion point) 찾기
```text
public int upperBound(int[] arr, int target) {
    int left = 0, right = arr.length;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] > target)
            right = mid;
        else
            left = mid + 1;
    }
    return left;
}
```


## 사용 시점 (언제 써야 하나)

**“정렬된 무언가”**가 주어졌을 때 무조건 떠올리자 🚀

| 🧩 상황 | 💡 사용 이유 |
|----------|---------------|
| 정렬된 배열에서 값 찾기 | 직접 탐색보다 빠름 |
| 정렬된 배열에서 삽입 위치 찾기 | `lower_bound` / `upper_bound` 활용 가능 |
| 최적화 문제 (조건 만족 최소값/최대값 찾기) | 결과가 **단조(monotonic)** 할 때 사용 |
| 매개변수 탐색 (Parametric Search) | 이진 탐색의 **확장 형태**, 조건을 만족하는 경계값 탐색에 적합 |