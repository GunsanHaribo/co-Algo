# 문제(질문 필수)

~~~text
두 개의 정수 배열 nums1과 nums2가 오름차순(비내림차순) 으로 정렬되어 있고, 정수 k가 주어집니다.

각 쌍 (u, v)는 첫 번째 배열에서 하나, 두 번째 배열에서 하나의 원소를 선택하여 구성됩니다.

합이 가장 작은 k개의 쌍 (u1, v1), (u2, v2), ..., (uk, vk)을 반환하세요.
~~~

## 문제 분석

1. 미지 : k개의 쌍 반환(topK)
2. 자료 : 오름차순인 정수 배열 2개
3. 조건 :
- (합이 가장 작은) k개의 쌍
- nums1, nums2 -> 오름차순 

## 문제 풀이

### Example 1

~~~text
Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
Output: [[1,2],[1,4],[1,6]]
Explanation: The first 3 pairs are returned from the sequence: 
[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
~~~

1. 모두 계산해서 넣어버린다. -> 시간초과
2. 경우를 어떻게 계산해서 넣어줘야될까? 100000개를

#### Time Limit Exceeded

- 아마도 지금 2중 for 문이여서 문제
    - 다만, num1기준 k개만 한다는 것은 뒤에 숫자중에 num2 최소랑 결합시 안되는게 좀 있음
- 두 배열의 원소를 비교해서 수가 더 큰것을 잡아서 값을 구한다?
- [1, 7, 11], [2, 4, 6]
- 1을 뽑고 [2,4,6] 돌고 -> 나머지 [7, 11] [2,4,6]   (1,2 1,4 ,16)
- 2를 뽑고 [7, 11] 돌고 -> 나머지 [7, 11] [4, 6]   (2,7, 2,11)
- 4를 뽁고 [7. 11] 돌고 -> 나머지 [7, 11] [6]   (4,7, 4,11)
- k 갯수를 채우면 stop, 이게 어느 배열 갯수를 제한해서 뽑을 수 가 없습니다;; 최소가 바뀌어요
- 그리고 할때마다 힙에서 배열을 뽑아줄 수는 없으니 포인터를 사용하겠습니다.

#### 이래도 안되네
- 일단 완전 투포인터로 진 -> 이래도 터짐
- k까지만 비교하게 한다? -> min(k, length)

### 이래도 안돼? : 다른 방법
- [2, 4, 6], [1, 4, 6]
1. 힙에는 총합을 넣어주자(디버깅하고 싶으면 인덱스도 같이 넣어주기)
2. nums1[0] 기준으로 최대한 만들어보고  -> min(length, k) 
3. k보다 부족하면 nums2[0]에서 num1[2~] -> min() 
4. 최대 최소를 비교할 필요가 있나.
- (1,1) (1, 4), (1,6) , length 또는 k까지하고 stop  
- nums1기준: (2, 1), (2, 4), (2, 6), 보다 -> nums2[0]기준: (4,1) (6,1)이 더 작다고 할 수는 없으니
- 어디 하나를 잡고 만드는게 이게 말이 되냐고, 최소를 보장할 수를 없는데 일단 k개를 만든다고 해도
- num1s[0], num2s[0] 기준으로 원소들 다 채우고, K개만 남겨놓습니다. 
- 위의 방식으로 하면 순서쌍이 작은 것부터 나오는게 보장이 될 수 있지만, 그냥 지금 찾는건 아니니깐
- K개의 집합만 찾으면 되니깐



## 링크
1. gpt 개선풀이 : https://leetcode.com/problems/find-k-pairs-with-smallest-sums/submissions/1633379665
2. 풀이 개선 : .. 없음... 딱히 다른 생각이 나지 않음 

## 회고 : 나와 다른점 
- [1, 7, 11], [1, 4, 6] 이면 7, 6보다 11,1이 더 빠르다, 이점에서 다시 한번 생각을 해볼 필요를 느끼지 않았나
- 처음에 너무 복잡하게 생각한거 아닌가, 다양한 방법 중에 최고로 좋은 방법을 선택하는 능력을 길러야한다. 
- 내부 for문을 도는데 너무 많은 숫자가 도니 N^2 수준으로 나와서 실패했던것 같습니다.
- (i,0)을 뽑았으면 nums2에서 그 다음수를 뽑아준다 
- TopK를 단순히 K개만 남겨준다고 생각했는데... 조금 더 고민해 봐야겠다. 이 문제의 본질이 뭐지? 


