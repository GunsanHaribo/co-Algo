# DP 이론 
## 1️⃣ 문제를 이해하라 (Understand the Problem)

### 🔍 핵심 질문
| 질문 | DP 관점에서의 해석 |
|------|------------------|
| 무엇을 구하라 하는가? | **최적값(최대/최소)** 또는 **경우의 수** |
| 현재 선택이 미래에 영향을 미치는가? | 그렇다면 DP 문제일 가능성이 높다 |
| 어떤 정보가 있어야 결정을 내릴 수 있는가? | 그것이 바로 **상태 변수(state)** |

### 📌 특징
- 최적화 문제: 최소 비용, 최대 이익, 최대 길이 등
- 결정이 미래에 영향을 미침 (→ 탐욕법과 차별점)
- 탐욕법: 지역적 결정이 전체 결과에 영향 없음
- DP: 각 결정이 미래에 누적되어 전체 결과에 영향

---

## 2️⃣ 계획을 세워라 (Devise a Plan)

### 🧩 DP의 핵심 구조
1. 문제를 **부분문제(subproblem)** 로 쪼갠다
2. 부분문제 간 관계를 **점화식(recurrence relation)** 으로 표현한다
3. **중복 계산**을 피하기 위해 **메모이제이션(memoization)** 을 사용한다
4. 문제의 상태를 표현하는 **상태 변수(state variables)** 를 설계한다

### 🔧 상태 변수 설계 예시
| 유형 | 예시 | 의미 |
|------|------|------|
| 인덱스(i) | `nums[i]`, `dp[i]` | 배열/문자열 위치 |
| 구간(i, j) | `dp[i][j]` | 특정 범위 |
| 수치 제약(k) | `k` | 남은 횟수, 예산 등 |
| 상태(boolean) | `holding`, `visited` | 현재 상태의 여부 |

> 🧠 여러 상태 변수가 존재하면 **다차원 DP** (예: `dp[i][j][k]`)

---

## 3️⃣ 계획을 실행하라 (Carry Out the Plan)

### ⚙️ 구현 방식 비교
| 방식 | 개념 | 장점 | 단점 |
|------|------|------|------|
| **Top-Down (하향식)** | 재귀 + 메모이제이션 | 직관적, 빠른 구현 | 재귀 오버헤드 |
| **Bottom-Up (상향식)** | 반복 + 테이블(tabulation) | 빠름, 공간 최적화 가능 | 다차원 순서 설계가 어렵다 |

### 💡 핵심 사고
> “현재 상태의 답은, 더 작은 상태들의 답으로부터 계산된다.”

---

# DP의 프레임 워크(상태, 점화, 기저)

## 3가지 구성요소
1. **주어진 상태에 대한 문제의 답을 계산하거나 포함할 함수 또는 데이터 구조**
- 첫째, 함수가 무엇을 반환하는지 결정해야 합니다. 둘째, 함수가 어떤 인수를 받아야 하는지(상태 변수) 결정
2. 상태 간 전환을 위한 점화식
- *100번째* 스텝에 오르는 최소 비용을 알아내고 싶다고 합시다
3. 기저 사례
- 점화식만으로는 쓸모가 없습니다. `dp(99)` 나 `dp(98)` 을 모르기 때문에 여전히 `dp(100)` 을 알아낼 수 없습니다
