# 풀이규칙
1. 연습문제는 최대 1시간, 실전문제는 2시간 넘으면 일단 다른 문제로
2. 재풀이전략
   1. 못 푼 문제 → 풀이을 보되 100% 이해 금지 : 왜 생각을 못했는지만 기록
   2. 느렸던 문제 → 병목 단계(자료구조/조건식/중첩루프) 표시
   3. 둘다 다음날 재풀이, 우선순위는 못 푼 문제
   4. 재풀이하면서 패턴기록
3. 날짜별로는 회고, 회고에서 패턴 추출

# 분석
1. 미지 : 가장 가까운 거리의 값 반환
2. 자료 : mat[]][] 0과 1이 있는 이중 배열 m*n
3. 시간 복잡도(3억) : 10^4^2 -> O(N)으로 끝내야함 
4. 조건 : 
- 0에 대한 가장 가까운 거리 반환
- 거리는 (노드 수 -1)
---
1. 전단계 :
   1. [[0,0,0],[0,1,0],[0,0,0]]
      - 1에서 가장 가까운 0, 상하좌우로 이동해서 0이 나오면 종료
   2. [[0,0,0],[0,1,0],[1,2,1]]
      - 1에서 상하좌우로 이동, 다음 이동 수가 1이면 거리+1 추가
      - 1이 있을떄마다 BFS를 한다면 1이 N-1개 있으면 BFS(O(N)) 바로 N^2인데
      - 1마다 BFS를 하는 방법말고, 다른 좋은 방법있을까?
      - BFS를 따로 두면 될 것 같긴한데,, 더 좋은 방법없나
   3. 1을 찾아서 1마다 BFS -> N^2이여서 안됨
   4. 0,0부터 탐색하는 방법  
     - 0,0에서 BFS를 하면서 1이 나오면, 1을 해당 숫자에 기록하고
     - 다음으로 넘어갈떄, count를 +1 해서 진행
     - 만약에 다음에 1이 나오면 record 배열에 현재 카운트에 +1한값을 기록
     - 0이 나오면 기록 안하고 count도 0으로 수정
     - 만약에 1하고 3같이 같은 숫자가 동시에?들어오려고 하면 어떻게 해야되나?
         - 먼저 방문을 했으면 방문을 못하게 하긴 해야되는데
         - 이러면 1에서 멀어진 거리를 계산할 수 이나 원래 둘중 최솟값으로 할라고 했는데
         - 마지막에서 state2랑 state0가 걸리는데, 어캐해야하누 이거
         - 일단 넣는데, 위치가 값은 개 있으면 count가 작은거로 바꾼다. -> count를 낮춘다.
         - 이걸 다시 넣기가 힘든데 어떻게 해야하나, 해시 셋으로 바꿔서 contain이면 count값 비교 후 수정
     - 방문할때 seen하면 값이 더들어가지, 큐에 넣어줄떄 seen해야됨
     - 이 방법도 만약에 3하고 0하고 각자 다른 값이 들어오면, 최소를 선택해야되는데, 이미 방문한건 다시 방문안하니깐 불가
     - 아니면 같은 레벨이면 일단 seen처리를 하지말까?, 레벨이 끝날때 seen처리를할까?
     - 아니면 넣기 전에 미리 담아두고, count가 최소인것만 남겨두고 몰아서 seen처리를 해버릴까? -> 이거는 int[]를 키로하는 해시맵으로 구현
     - seen처리를 미뤄버리면 재탐색하는 그니깐 들어간 노드중에 겹치는 부분 이있긴한데 이걸 해시맵으로 통제를 하는건데
   5. 상하좌우 전체, 밑에 0에도 영향을 받아야함, 위에서 내려오는  0이아니라
      - 그렇다면 모든 0에서 시작하는건 어떨까?, 0에서 시작해서 최단 거리로 가는건 어떤데
      - 1에서 시작하는 것도 나쁘지 않을 것 같긴하데, 표가 원하는건 1이있는 자리에 표시가 되어야함
      - 시작점을 있는 숫자 중에서 바꿀 생각도 해얗마

2. 기능 :
   - 
   

# 패턴
- poll은 안에 있어야합니다.
```text

```

# 회고
- 안풀릴떄는 어떻게 해야되지?, 가능할 것 같은 풀이들이 나오긴하는데, 이걸 어떻게 관리해야되나?
- 불가능한 풀이들을 어떻게 다시 활용해볼 수는 없을까?, 조금 더 나아가면 풀릴 수 있다는 걸 어떻게알지?
- 조금 더 나아갈까, 아니면 다른 풀이 방법을 시도해볼까 이걸 어떻게 결정을 하지?

- seen 처리를 뒤로 미뤄서 성공한다면, BFS 템플릿에 기능을 언제든지 문제에따라 바꿀 수 도 있는거잖아
- 기능별 순서 처리 같은 것도 고민해야겠는 

- 일단 이렇게 푸는게 아닌것 같긴해~
- 안 풀릴떄는 어떻게 접근 하는게 좋 

- 각 기능별 예시를 들어야 되나? 이렇게 하면 더 구현하기가 쉬우려나? -> 기능별 예시
- 주석으로 쓰지말고 전단계할때 써야될것 같은데

- 이상태에서 엣지 케이스를 발견하라고? 이건 ㄹㅇ 힘들것 같은