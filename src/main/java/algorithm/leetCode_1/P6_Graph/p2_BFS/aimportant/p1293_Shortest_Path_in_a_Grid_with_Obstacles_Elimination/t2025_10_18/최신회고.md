## 문제에 대한 이해
- 미지인 것은 무엇인가? 자료는 무엇인가? 조건은 무엇인가?
- 조건은 만족될 수 있는가 조건은 미지인것을 결정하기에 충분한가 돈느 불충분한가 또는 과다한가, 또는 모순되는가?
- 그림을 그려보아라. 적절한 기호를 붙여라
- 조건은 여러 부분으로 분해하라. 그것을 써서 나타낼 수 있는가?

## 계획의 작성
- 전에 그 문제를 본일이 있는가? 그렇기 않다면 약간 다른 형태로 된 같은 문제를 본일이 있는가?
- 관련된 문제를 알고 있는가? 유용하게 쓰일 수 있을 듯한 어떤 정리를 알고 있는가?
- 미지인 것을 살펴보아라, 친숙한 문제 중 미지인 것이 같거나 유사한 문제를 생각해 보아라
- 관련된 문제로 전에 풀어 본일이 있는 문제가 있구나 그것을 활용할 수 있을까? 어떤 보조 요소를 도입하면 그것을 활용할 수 있을까?
- 문제를 달리 진술할 수 있을까? 좀 더 다르게 진술 할 수 있을까? 정의로 되돌아가 보자
- 만일 제기된 문제를 풀 수 없다면, 먼저 어느정도 그와 관련된 문제를 풀어 보아라.
    - 보다 쉬운 관련된 문제를 생각해 낼 수 있는가, 보다 일반적인 문제는?, 보다 특수한 문제는, 유사한 문제는?
    - 문제를 부분적으로 풀 수 있는가?
    - 조건 가운데 일부부만 남기고 다른 것은 버려보아라. 그랬을때 미지인 것은 어느 정도까지 정해지는가?
    - 자료로부터 무언가 유용한 것을 이끌어 낼 수 있는가?
    - 미지인 것을 결정하는 데 적절한 다른 자료를 생각해 볼 수 있을까?
    - 새로운 미지인 것과 새로운 자료가 서로 보다 더 가깝게 되도록 하기 위해서 미지인 것이나 자료 또는 필요하다면 두가지를 다 변형 할 수 있을까?
- 자료는 모두 사용하였는가 문제에 포함된 핵심적인 개념은 모두 고려 하였는가?

## 계획의 실행
- 매 단계를 점검하라, 그것이 옳다는 것을 증명할 수 있는가?

## 반성
- 결과를 점검할 수 있는가? 논증과정을 점검할 수 있는가?
- 결과를 다른 방법으로 이끌어 낼 수 있는가? 그것을 한눈에 알 수 있는가?
- 결과나 방법을 어떤 다른 문제에 활용할 수 있는가?

----

# 1. 이해
1. 미지 : 최소 걸음 수
2. 자료 : grid(행렬), k(최대 장애물 치울 수 있는 수)
3. 조건(자취) : 
- 왼쪽 위 모서리(0,0)에서 오른쪽 아래 모서리(n-1,n-1)까지 이동
- k번 최대 장애물을 제거할 수 있다

# 2. 계획
- 시간 복잡도 상한(3억) :  N = 40^2 -> N^2까지
1. 유사한 문제 : 행렬+최소 = BFS
2. 문제를 다르게 진술하기 : 
3. 만일 제기된 문제를 풀 수 없다면 :
4. 선행 : 결과 6이려면, ((3,2))를 치웠다는 이야기인데, 3,2를 어떤 기준으로 치워야되지?
   1. 안되는 생각 : 다 뚤어보고 비교해야됨?, 아 근데 이렇게 해도 아 안된다. k가 2이 상이면 N!*N 나올 수도 
   2. 장애물이 있으면, 제거했을떄 안했을떄 2가지 케이스로 갈까?  -> 이러면 N 나올 것 같은데 
      - 다 치웠으면 못치우게 하자, count를 중간에 해서
      - 갈수 없다면 -1이 있어야합니다. -> 처음에 -1로 채우자
      - 같은 자리로 들어왔는데 k가 높은게 먼저 들어와서 

# 3. 실행 
1. 기능(예시 포함) :

# 4. 반성
1. 다른 방법으로 풀 수 있는가?: 시간 복잡도가 허락한다면 N^2으로?
2. 결과나 방법을 다른 문제에 활용할 수 있는가 ?: 글쎼... 2가지를 모두 넣는다는게 쉬운 일은 아닌데 

# 5. 패턴 코드
```text

```

아 그런데 아까처럼 진짜 답이 안나오면 어떻게하지
-> 뒤에서 부터 들어가는 것도 방법

모르는거, 못정하는거 이거 적어놔 -> 이걸 어떻게 할지 고민
상황이 여러개면 여러개 다 하는것도 좋을 수도

거리 나오면 state 넣어

중간에 이렇게 틀리는건 어떻게 해야되나?
중간에 k가 왜 올라가지? (1,1)울 먼저 마킹하네, 이렇게하면 1일떄는 seen마킹을 하면 안되겠는데
seen 마킹을 해버리면, 0이 아닌 수가 못들어옴
(1,1,1) (y,x,k)가 어디서 들어오는지를 모르겠는데, 어디서 111이 만들어지
지금 상태가 grid1이면 seen표시를 안하게해야겠중간에 하나가 틀렸을떄 이거 어떻게 할건가

- 겹치는게 있으면 최솟값을 넣던가 그러면, 아니면 priorityQueue로 최솟값만넣어놔 그냥
- 그리고 재진입..을 허용하던가, 해야될것 같은 
- 상태 값들을 보고 예상과 다른 값들을 찾아야함

- 디버깅 시점을 보는 것도 어려운데 이거, 정확히는 어디를 잡아야될지 모르겠긴함

- 지금 할거는 한놈이 들어왔을때, 왜 작은게 묵살되는가?