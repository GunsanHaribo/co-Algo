## 문제에 대한 이해
- 미지인 것은 무엇인가? 자료는 무엇인가? 조건은 무엇인가?
- 조건은 만족될 수 있는가 조건은 미지인것을 결정하기에 충분한가 돈느 불충분한가 또는 과다한가, 또는 모순되는가?
- 그림을 그려보아라. 적절한 기호를 붙여라
- 조건은 여러 부분으로 분해하라. 그것을 써서 나타낼 수 있는가?

## 계획의 작성
- 전에 그 문제를 본일이 있는가? 그렇기 않다면 약간 다른 형태로 된 같은 문제를 본일이 있는가?
- 관련된 문제를 알고 있는가? 유용하게 쓰일 수 있을 듯한 어떤 정리를 알고 있는가?
- 미지인 것을 살펴보아라, 친숙한 문제 중 미지인 것이 같거나 유사한 문제를 생각해 보아라
- 관련된 문제로 전에 풀어 본일이 있는 문제가 있구나 그것을 활용할 수 있을까? 어떤 보조 요소를 도입하면 그것을 활용할 수 있을까?
- 문제를 달리 진술할 수 있을까? 좀 더 다르게 진술 할 수 있을까? 정의로 되돌아가 보자
- 만일 제기된 문제를 풀 수 없다면, 먼저 어느정도 그와 관련된 문제를 풀어 보아라.
    - 보다 쉬운 관련된 문제를 생각해 낼 수 있는가, 보다 일반적인 문제는?, 보다 특수한 문제는, 유사한 문제는?
    - 문제를 부분적으로 풀 수 있는가?
    - 조건 가운데 일부부만 남기고 다른 것은 버려보아라. 그랬을때 미지인 것은 어느 정도까지 정해지는가?
    - 자료로부터 무언가 유용한 것을 이끌어 낼 수 있는가?
    - 미지인 것을 결정하는 데 적절한 다른 자료를 생각해 볼 수 있을까?
    - 새로운 미지인 것과 새로운 자료가 서로 보다 더 가깝게 되도록 하기 위해서 미지인 것이나 자료 또는 필요하다면 두가지를 다 변형 할 수 있을까?
- 자료는 모두 사용하였는가 문제에 포함된 핵심적인 개념은 모두 고려 하였는가?

## 계획의 실행
- 매 단계를 점검하라, 그것이 옳다는 것을 증명할 수 있는가?

## 반성
- 결과를 점검할 수 있는가? 논증과정을 점검할 수 있는가?
- 결과를 다른 방법으로 이끌어 낼 수 있는가? 그것을 한눈에 알 수 있는가?
- 결과나 방법을 어떤 다른 문제에 활용할 수 있는가?

----

# 1. 이해
1. 미지 : 최소 걸음 수
2. 자료 : grid(행렬), k(최대 장애물 치울 수 있는 수)
3. 조건(자취) : 
- 왼쪽 위 모서리(0,0)에서 오른쪽 아래 모서리(n-1,n-1)까지 이동
- k번 최대 장애물을 제거할 수 있다

# 2. 계획
- 시간 복잡도 상한(3억) :  N = 40^2 -> N^2까지
1. 유사한 문제 : 행렬+최소 = BFS
2. 문제를 다르게 진술하기 : 
3. 만일 제기된 문제를 풀 수 없다면 :
4. 선행 : 결과 6이려면, ((3,2))를 치웠다는 이야기인데, 3,2를 어떤 기준으로 치워야되지?
   1. 안되는 생각 : 다 뚤어보고 비교해야됨?, 아 근데 이렇게 해도 아 안된다. k가 2이 상이면 N!*N 나올 수도 
   2. 장애물이 있으면, 제거했을떄 안했을떄 2가지 케이스로 갈까?  -> 이러면 N 나올 것 같은데 
      - 다 치웠으면 못치우게 하자, count를 중간에 해서
      - 갈수 없다면 -1이 있어야합니다. -> 처음에 -1로 채우자
      - 같은 자리로 들어왔는데 k가 높은게 먼저 들어와서 

# 3. 실행 
1. 기능(예시 포함) :

# 4. 반성
1. 다른 방법으로 풀 수 있는가?: 시간 복잡도가 허락한다면 N^2으로?
2. 결과나 방법을 다른 문제에 활용할 수 있는가 ?: 글쎼... 2가지를 모두 넣는다는게 쉬운 일은 아닌데
   https://leetcode.com/problems/shortest-path-in-a-grid-with-obstacles-elimination/submissions/1808137048


# 5. 패턴 코드
```text

```

아 그런데 아까처럼 진짜 답이 안나오면 어떻게하지
-> 뒤에서 부터 들어가는 것도 방법

모르는거, 못정하는거 이거 적어놔 -> 이걸 어떻게 할지 고민
상황이 여러개면 여러개 다 하는것도 좋을 수도

거리 나오면 state 넣어

중간에 이렇게 틀리는건 어떻게 해야되나?
중간에 k가 왜 올라가지? (1,1)울 먼저 마킹하네, 이렇게하면 1일떄는 seen마킹을 하면 안되겠는데
seen 마킹을 해버리면, 0이 아닌 수가 못들어옴
(1,1,1) (y,x,k)가 어디서 들어오는지를 모르겠는데, 어디서 111이 만들어지
지금 상태가 grid1이면 seen표시를 안하게해야겠중간에 하나가 틀렸을떄 이거 어떻게 할건가

- 겹치는게 있으면 최솟값을 넣던가 그러면, 아니면 priorityQueue로 최솟값만넣어놔 그냥
- 그리고 재진입..을 허용하던가, 해야될것 같은 
- 상태 값들을 보고 예상과 다른 값들을 찾아야함

- 디버깅 시점을 보는 것도 어려운데 이거, 정확히는 어디를 잡아야될지 모르겠긴함
-----
- 지금 할거는 한놈이 들어왔을때, 왜 작은게 묵살되는가?
- 문제는 여기서 뭐가 문제인지 모르겠다는거임, 이렇게 해결력이 안좋았었나 
- 문제가 뭔지 찾지 못한다는게 조금 더 큰데, 한번 큐에 들어가는걸 쭉 써보자
- (0,0,0,0)
- (0,1,1,0), (1,0,1,1)
------------
- K가 큰게 먼저들어가서 그럼, 그럼 중간에 K가 한번들어가게 바꾸자, 시간복잡도가 조금 쫄리긴 함, 한번더 꺼내주는건 맞으니깐
- 장애물 치운게 먼저 가버려서 seen을 처리가 미리 되어버려서 막힘
- 장애물 치운 전적이 있으면 seen처리를 못하게 해야되나 싶기도 하고, 근데 그러면 1이 많은 곳에서는 여러대가 날뛸텐데
- 1이 통과한걸 다른 노드가 통과하도록(다시 통과할 수도 있으니깐)
- 그렇다고 seen을 뚤어버리기에는... 벽을 뚫은 노드는 seen을 시키지 않는다던지, 다른 애들이 들어올 수 있으니깐 
- seen을 안시키면 근데, 벽울 뚫은거에서 다시 재방문할 수 도 있잖아
- 아니면 벽을 뚫은 것 끼리 seen을 따로 만들까? -> 이게 문제가되나?, 다시 뚫면 어떻게하게 
- k, seen이 문제니,,, seen을 숫자 형태로 만들어야되나?, 만약에 뚫은 횟수가 더 낮은게 들어온다면,
- 들어오고, 뚫은 횟수가 더 높은게 들어온다면, 안들어오고?, 뚫은 횟수가 더 적은게 들어와야되긴함
- 많은게 들어오면, 통과시켜줄 이유가 있나?, 이건 좀 고민이 되는구만, 더 뚫었던게 나중에 최솟값을 안겨줄수 있나?
  - 내 생각은 아니다, 더 뚫어서 같은 위치에 왔으면, 나머지 count는 똑같기 떄문에 필요없다.
  - 더 뚤었을떄 이전 카운트가 더 작을 수도 있지않나? -> 이전 카운트가 작으면 먼저 통과 되었어야되는게 맞고
  - 그리고 본인보다 작은거, 들어가게 해주는게 맞다. 근데 -1나오네;;
-----
- 디버거 돌려서 문제가 맞는지 보고, 그 다음에 어떻게 할건지 생각
- 이거 통과하면, 템플릿의 자료구조를 바꿀 생각도 해야되겠는데
- 템플릿의 자료구조나 로직을 정할떄는 (seen, k, count) 같이 현재 영향을 미치는 애들을 기준으로
- bool -> int로 바꾸면 어떻게 하겠다.
----------

# 정리
1. 기존 템플릿에서 문제가 되는 부분 파악
   - seen을 다시한번 건너가야되는데, 못감
     - k=1인 부분이 먼저 지나버리면, seen 처리가되서 k=0이 방문당했던 루트로 못감
     - 이러면 최대가 나오지 않을 수도, 목적지에 방문을 아예 못할수도
     - 그렇다고 seen을 다시 없애자니, 중복방문으로 while문이 안끝날수도 -> seen 변형필요, 다만 어떻게?
2. 문제가 왜되는지 파악 -> 문제가 되는 부분 변수(k) +)count는 이게 문제가 되지 않을까? 부가요소
   - seen이 문제가 되는 변수는 k
     - k를 1일떄 먼저 통과했다면, 그리고 k가 0일떄 통과해야한다면 1보다 작을떄만 통과하면 되지않을까?
     - count는 고려하지 않아도 되나?, count가 큰데 k가 작을 수가 있을까?
       - count가 같은 경우 
         - k가 크다면, 앞으로의 갈길도 같고, 뒤에 있을 장애물을 치울수도 없으므로 삭제
         - k가 작다면, 들어가도됨, 미래에 장애물 최우면서 애가 최소가 될수도
         - 둘다 같으면 아예 같은건데 안들어가도됨
       - count가 큰경우
         - k가 크다면, 이미 치울 수 있는 장애물은 적고, 더 돌아왔으니 최소가 될일은 없음
         - k가 작다면, 들어갈만함, 들어가서 장애물 치우면서 최소가 될수도
         - k가 같다면, 뒤에서 장애물을 치울 수 있는 횟수는 같은데, 돌아왔으니 더 들어갈 필요없음
       - count가 작은 경우는 후발 주자가 아니라, 먼저 들어간 사람이어서 딱히 고민 안해도 됨
         - 이미 들어가서 k깔고 있음
3. answer는 중복해서 방문할 수 있으므로 최소만 기록
4. 결론은 "새로 변수에 참고해서 템플릿의 자료구조를 바꾸는 방법"
   - 템플릿에서 문제가 되는 부분을 찾고 -> k, seen
   - 문제를 이루는 변수파악 +)현상을 자세히 기록하면서, 
     - k가 더 작은게 미리 seen되서 못들어감
   - 변수를 통해서 템플릿(자료)를 어떻게 바꿀까 고민
     - seen은 없애는건, 중복 방문으로 무한 루프떄문에 안됨, 자료구조를 어떻게 바꿀까 고민
     - seen에 더작은 k를 기록하고, k가 작은건 통과하게 하자



