# 풀이규칙
1. 연습문제는 최대 1시간, 실전문제는 2시간 넘으면 일단 다른 문제로
2. 재풀이전략
   1. 못 푼 문제 → 풀이을 보되 100% 이해 금지 : 왜 생각을 못했는지만 기록
   2. 느렸던 문제 → 병목 단계(자료구조/조건식/중첩루프) 표시
   3. 둘다 다음날 재풀이, 우선순위는 못 푼 문제
   4. 재풀이하면서 패턴기록
3. 날짜별로는 회고, 회고에서 패턴 추출

# 분석
1. 미지 : 노드0에서 노드X로 가는 가장 짧은 경로의 길이 -> answer[x] 반환, 없으면 -1 입력, 최종은 0<=x<=n인 answer반환
2. 자료 :  n = 3, redEdges(노드간 빨간색 모서리), blueEdges(노드간 파란색 모서리) = [] 둘다 유방향
3. 시간 복잡도 상한(3억) :  N^2까지 가능한듯
4. 조건 : 
- 각 간선은 빨간색 또는 파란색
- 자기 자신으로 가는 간선(self-edge)과 평행 간선(parallel edges)도 있음 ->?
- 0에서 x를 향하는 path의 간선의 색은 번갈아가며 나와야한다. 
- 번갈아 나올 수가 없으면 answer[x]에서 -1을 놓는다는 이야기고
---
1. 전단계 : 
   - [0,1,-1]
   - -1은 0->1이지만 다음이 blueEdges가 없어서 불가
   - 1은 노드 1로 갈수있는게 red에 있어서,
2. 가능한 풀이들 :
   1. Blue로 시작했을떄랑, red로 시작했을때 두가지 케이스 나누고, 일단 BFS로 진행, 두가지 케이스 비교해서 가장 짧은 길이 반환
      - -> 없으면 -1
3. 기능(예시 포함) :
   1. 간선 배열 -> 인접리스트로 정리 필요
   2. 기본적인 BFS방식
   3. blue, red 번갈아가면서 갈수있도록, blue일떄 red일떄 표시해야함
   4. 또한, 2번노드로 간다면,1번 노드의 최단거리가 영향을 주지않나
     - 0,1(r) 1,2(b) -> 0,2(b) 이렇게 갈수도있어서 이전꺼 참고하지 말고 x별로 따로 돌리는거 추천 
   5. 뭔가가 안되네, seen을 2개 놔볼까?

# 패턴
```text

```

https://leetcode.com/problems/shortest-path-with-alternating-colors/submissions/1805207360


# 회고(반성, 결과 활용)
- 치는 시간을 이거 어떻게 해야되는데, 뭔가 길어지네 시간이 계속
- 몇시간 걸려서 이거 하나하면 무슨 소용이야 이
 