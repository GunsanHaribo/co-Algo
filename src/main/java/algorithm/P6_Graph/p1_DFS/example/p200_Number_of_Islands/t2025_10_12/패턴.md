# 풀이규칙
1. 연습문제는 최대 1시간
2. 실전문제는 무제한

# 분석

1. 미지 : 섬의 개수를 반환
2. 자료 : m*n 행렬
3. 조건 : 
   1. 시간 복잡도(3억)
      - 300이면 N^N만아니면 될듯
   2. 키워드
      - 섬의 갯수, 섬은 물로 둘러 쌍여있습니다.  
4. 전단계
   - 출력 1 
   - 다 돌아야 될 것 같긴다. 섬 = 전체 for, unseen만 count, dfs
5. 기능
   - 이중리스트의 전체를 한번 다 도는 기능 
   - 연결된 1인 부분만 다도는 기능
   - 벽하고 0 인 부분은 들어가지 못함

# 패턴
- 행렬 : 상하좌우
- dfs탈때 nextX,Y
- 행렬범위 체크
- O(nodes + edges) : 
  - DFS나 BFS는 그래프의 모든 노드(node) 를 방문하면서, 각 노드의 모든 간선(edge) 을 “한 번씩” 확인한다.
```text
boolean[][] seen;
int[][] dirs = {{-1,0},{1,0},{0,-1},{0,1}}; // 상하좌우

int numIslands(char[][] grid) {
    int m = grid.length, n = grid[0].length;
    seen = new boolean[m][n];
    int count = 0;

    for (int y = 0; y < m; y++) {
        for (int x = 0; x < n; x++) {
            if (grid[y][x] == '1' && !seen[y][x]) {
                dfs(y, x, grid, m, n);
                count++;
            }
        }
    }
    return count;
}

void dfs(int y, int x, char[][] grid, int m, int n) {
    seen[y][x] = true;
    for (int[] d : dirs) {
        int ny = y + d[0], nx = x + d[1];
        if (ny < 0 || ny >= m || nx < 0 || nx >= n) continue; // 경계
        if (grid[ny][nx] == '1' && !seen[ny][nx])
            dfs(ny, nx, grid, m, n);
    }
}
```

애가 말하는거는 이런걸 해시 맵으로 변환을 먼저 하라는거 아닐까?
그런 생각이 많이 드네, 

https://leetcode.com/problems/number-of-islands/submissions/1799345042