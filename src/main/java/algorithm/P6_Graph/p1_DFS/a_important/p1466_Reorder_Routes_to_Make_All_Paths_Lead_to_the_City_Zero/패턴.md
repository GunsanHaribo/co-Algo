# 풀이규칙
1. 연습문제는 최대 1시간
2. 실전문제는 무제한

# 분석

1. 미지 : 변경된 간선의 최소 개수를 반환
2. 자료 : connections -> 간선 행렬 -> 인접리스트 전환 필요, 방향 그래프임
3. 조건 : 
   1. 시간 복잡도(3억)
      - 5 * 10^4 제곱하면 위험함  NlogN까지 가능
   2. 키워드
      - 각 도시가 수도를 방문할 수 있도록 도로의 방향을 바꾼다. -> 이것의 최소 갯수
4. 전단계
   - 출력 : 3
   - 순회는 해야됨, 
   - 원하는건 이거
     - 5 : 4
     - 4 : 0
     - 3 : 1
     - 2 : 3
     - 1 : 0
   - 무방향 그래프 
     - 5 : 4
     - 4 : 5, 0
     - 3 : 2, 1
     - 2 : 3
     - 1 : 0
   - 현재 방향 그래프(이걸로 잡고)
     - 5 : 
     - 4 : 0
     - 3 : 
     - 2 : 3
     - 1 : 3
   - 서로 다른게 3개 :  5 -> 4, 3 -> 1, 1 -> 0
5. 기능 
   - 유방향 그래프를 무방향 그래프로 변경하기 
   - 무방향 그래프로 각자 노드에서 0으로 가는 루트 구하기 or 0에서 각자 노드로 가던지(리버스로 저장하면 되니깐)
     - 무방향 그래프 만들기
     - 0으로 가는 루트 기록하고 HashMap에 넣어두기
     - 5- > 4
     - 2 -> 3 -> 1 -> 0 이면, 2->3, 3-> 1, 1->0 으로 만들어야함
     - 이게 각노드를 기록한 HashMap에서 0을 갈수 없는 노드들을 뺴는게 0에 도착할 수 없음을 알았을떄, 도달한 지점을 뺴는게 가능하지 않다.
     - List로 기록하던가 해야되는데 너무 꼬일 것 같음
   - 0에서 각 노드로 가는 방법도 있음
     - 0 -> 1 -> 3 -> 2
     - 0 -> 4 -> 5
     - 하고 다 도착했으면(?), seen으로 묶어 놓고 갈데가 없으면 그떄 부터 해체?
     - 아니면 0,4로 들어가면 들어오면 이전 노드랑 현재 노드 매개변수에 넣어서 거꾸로 HashMap에 넣자
- 기능 
1. 무방향 그래프 만들기
2. 0에서 부터 각 노드 따라서 이동 -> 이동 가능하면 HashMap에 거꾸로 기록하기, +) 이미 방문한 노드는 seen으로 방문처리
3. 처음 유방향 그래프하고 비교합니다. 각 키의 value에서 없는거 count
   
근데 이렇게 하려면 각 노드마다 0으로 가는길이 하나로 정해져 있어야 되긴 하는데

# 패턴
```text


```

최대, 최소를 잘 해야되는데
트리, 그래프등 최대 최소를 잘해야됨
언제 최소가 나올지 모두 다 뒤져보는거는 아니잖아



https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/submissions/1799549803

문제가 있긴하네....