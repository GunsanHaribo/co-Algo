# 풀이규칙
1. 연습문제는 최대 1시간, 실전문제는 2시간 넘으면 일단 다른 문제로
2. 재풀이전략
   1. 못 푼 문제 → 풀이을 보되 100% 이해 금지 : 왜 생각을 못했는지만 기록
   2. 느렸던 문제 → 병목 단계(자료구조/조건식/중첩루프) 표시
   3. 둘다 다음날 재풀이, 우선순위는 못 푼 문제
   4. 재풀이하면서 패턴기록
3. 날짜별로는 회고, 회고에서 패턴 추출

# 분석
1. 미지 : 변경된 간선의 최소 갯수를 반환
2. 자료 : n, connections(방향 그래프)
3. 시간 복잡도(3억) :  5 * 10^4 -> NlogN이 최대, DFS/BFS 한번이 최대
4. 조건 :
- 각 도시가 0을 방문할 수 있도록 바꿔야 합니다.
- 간선의 "최소" 갯수를 찾아야합니다.
---
1. 전단계
   1. 3
     - 4-> 5를 5->4로
   2. 2
     - 1 -> 3을 3->1로
   3. 1
     - 0->1을 1->0로
   - 문제는 그러면 4->5, 1->3, 0->1을 어떻게 찾을 것인가?로 바뀐다.
   - 0에서 시작해서 돌면서 4->5 같이 0에서 멀어지는 경우가 있으면 count++
2. 기능
   1. 무뱡향그래프 만들기, 방향의 start-end 기록
   2. 0부터 탐색 무방향 그래프를 돌면서 같은 start

# 패턴
```text
무방향 그래프 생성
방향그래프 기록

0에서 멀어지기, 멀어질떄 방향그래프와 같은 방향있으면 count++
```

https://leetcode.com/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/submissions/1801498334


# 회고
- 어떻게 해야 최소인걸 알지?
  - 이게 0에서 멀어지는 방향을 count 하는건 인정인데, 이걸 어떻게 count 하지? 
- 핵심 : 문제는 그러면 4->5, 1->3, 0->1을 어떻게 찾을 것인가?로 바뀐다.
- 방문했던거 다시 방문할 수 있나?는 무뱡향 그래프여서 넣어줘야함
- getOrDefault 좀 바꿔줄 수 있을까?
- 시간 복잡도는 여전히 안좋은