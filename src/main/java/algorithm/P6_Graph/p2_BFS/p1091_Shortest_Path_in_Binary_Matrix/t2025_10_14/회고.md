# 풀이규칙
1. 연습문제는 최대 1시간, 실전문제는 2시간 넘으면 일단 다른 문제로
2. 재풀이전략
   1. 못 푼 문제 → 풀이을 보되 100% 이해 금지 : 왜 생각을 못했는지만 기록
   2. 느렸던 문제 → 병목 단계(자료구조/조건식/중첩루프) 표시
   3. 둘다 다음날 재풀이, 우선순위는 못 푼 문제
   4. 재풀이하면서 패턴기록
3. 날짜별로는 회고, 회고에서 패턴 추출

# 분석
1. 미지 : 가장 짧은 경로의 길이를 반환
2. 자료 : grid : 행렬 -> seen, 경계
3. 시간 복잡도(3억) : n ==100, N = 10^4니깐 제곱이 간당간당 하는데 일단 되는데, O(N+8)이 왜 시간초과가 나는거지? 
4. 조건 :
- 8방향으로 연결됨
- 0,0에서 n-1,n-1까지 이동
- 0을 타고 들어가면 됨
---
1. 전단계
   1. 4 : (2, 2)
   2. 3 : (1, 2) -> 8방향 돌리는 기능, 근데 순차적으로 들어
   3. 2 : (0, 1)
   4. 1 : (0, 0)
   - 시간 복잡도는 하나하나 지나면서 count 하는게 유리함
   - 노드를 센다기보단 단계를 세자
2. 기능
   1. 8방향 이동
   2. depth count++

# 패턴
- 그래프에서 BFS란 뭘까?
```text
queue.size() 한 다음  
for문
```

https://leetcode.com/problems/shortest-path-in-binary-matrix/submissions/1801594215

# 회고
- 최단 경로 == BFS
- BFS는 “가까운 곳부터 방문”하니까, 어떤 노드에 처음 도달했을 때, 이미 그게 최단 거리임이 보장
- count 같이 기록하기가 쉽지가 않네 -> depth별 count가 쉽지가 않아 
- 경계도 공식으로 외우
- 시간 복잡도(3억) : n ==100, N = 10^4니깐자제곱이 간당간당 하는데 일단 되는데, O(N+8)이 왜 시간초과가 나는거지?
  - 시간복잡도가 곱하기일떄, 더하기일떄는 모르겠네
  - O(N)인데 왜 시간복잡도가 터지지
  - seen[polled[0]][polled[1]]의 위치 문제