# 개념 정리

- 방향성(directed) 또는 무방향성(undirected)
- 연결 요소(connected component)
- 그래프를 순회할 때는 노드가 임의의 개수의 이웃을 가질 수 있으므로 현재 노드의 이웃을 반복하기 위해 for 루프

1. 첫 번째 입력 형식: 간선 배열
   - 간선 배열만으로는 탐색할 때 매번 전체를 돌아야 해서 비효율적이니, 해시맵 기반의 인접 리스트를 전처리로 만들어두면 탐색이 훨씬 빨라진다
```text
  public Map<Integer, List<Integer>> buildGraph(int[][] edges) {
    Map<Integer, List<Integer>> graph = new HashMap<>();
    for (int[] edge: edges) {
        int x = edge[0], y = edge[1];
        if (!graph.containsKey(x)) {
            graph.put(x, new ArrayList<>());
        }
        graph.get(x).add(y);
          
        // if (!graph.containsKey(y)) {
        // graph.put(y, new ArrayList<>());
        // }
        // graph.get(y).add(x);
        // uncomment the above lines if the graph is undirected
        }
        
        return graph;
    }
```
2. 두 번째 입력 형식: 인접 리스트
   - 인접 리스트 입력 형식은 탐색할 때 바로 graph[node]로 이웃을 얻을 수 있어서 가장 편리하고 효율적이다.
```text
int[][] graph = {
    {1},      // 0번 노드 이웃
    {2},      // 1번 노드 이웃
    {0, 3},   // 2번 노드 이웃
    {}        // 3번 노드 이웃
    };

// 예: 2번 노드의 모든 이웃 출력
for (int neighbor : graph[2]) {
System.out.println(neighbor);
}
// 출력: 0, 3
```

3. 세 번째 입력 형식: 인접 행렬
   -  행(row)은 출발 노드, 열(column)은 도착 노드
```text
int[][] graph = {
    {0,1,0,0},
    {0,0,1,0},
    {1,0,0,1},
    {0,0,0,0}
};

// 2번 노드 이웃 찾기
for (int v = 0; v < graph[2].length; v++) {
    if (graph[2][v] == 1) {
        System.out.println("Neighbor: " + v);
    }
}
// 출력: 0, 3
```
4. 마지막 입력 형식: 행렬
   - DFS/BFS 할떄 같이 주어진 배열 전체가 그래프일떄
```text
int[] dr = {-1, 0, 0, 1};
int[] dc = {0, -1, 1, 0};

boolean inBounds(int r, int c, int R, int C) {
    return 0 <= r && r < R && 0 <= c && c < C;
}

// DFS 예시
void dfs(int r, int c, int[][] grid, boolean[][] vis) {
    vis[r][c] = true;
    for (int k = 0; k < 4; k++) {
        int nr = r + dr[k], nc = c + dc[k];
        if (inBounds(nr, nc, grid.length, grid[0].length)
            && !vis[nr][nc]
            && passable(grid, nr, nc)) { // 문제 규칙(벽/조건) 체크
            dfs(nr, nc, grid, vis);
        }
    }
}

// BFS 예시 (무가중치 최단거리)
int bfsDist(int sr, int sc, int tr, int tc, int[][] grid) {
    int R = grid.length, C = grid[0].length;
    boolean[][] vis = new boolean[R][C];
    int[][] dist = new int[R][C];
    ArrayDeque<int[]> q = new ArrayDeque<>();
    q.add(new int[]{sr, sc}); vis[sr][sc] = true;

    while (!q.isEmpty()) {
        int[] cur = q.poll();
        int r = cur[0], c = cur[1];
        if (r == tr && c == tc) return dist[r][c];

        for (int k = 0; k < 4; k++) {
            int nr = r + dr[k], nc = c + dc[k];
            if (inBounds(nr, nc, R, C) && !vis[nr][nc] && passable(grid, nr, nc)) {
                vis[nr][nc] = true;
                dist[nr][nc] = dist[r][c] + 1;
                q.add(new int[]{nr, nc});
            }
        }
    }
    return -1; // 도달 불가
}

// 예: 통과 가능 조건(문제에 맞게 변경)
boolean passable(int[][] grid, int r, int c) {
    return grid[r][c] != 1; // 1이 벽이라 가정
}
```


- 그래프와 트리 간의 코드 차이점(방문체크가 필요하다)
  - 트리는 root부터 단방향(하향식)이라 단순하지만, 그래프는 시작점이 자유롭고 사이클 방지를 위해 방문 체크가 반드시 필요하다.
1.	시작점
  •	트리: 항상 root에서 시작
  •	그래프: 문제마다 다름 (0번 노드, 임의 노드, 모든 노드 등)
2.	이웃 접근 방식
  •	트리: node.left, node.right (자식이 고정 2개)
  •	그래프: for (nei : graph[node]) (이웃 개수가 가변적)
3.	사이클 여부
  •	트리: 사이클 없음 → 방문 체크 필요 없음
  •	그래프: 사이클 가능 → visited/seen으로 방문 체크 필수
4.	구현 패턴
  •	트리 DFS:
```text
void dfs(TreeNode node) {
    if (node == null) return;
    dfs(node.left);
    dfs(node.right);
}
```
•	그래프 DFS:
```text
void dfs(int node, Map<Integer,List<Integer>> graph, Set<Integer> seen) {
    if (seen.contains(node)) return;
    seen.add(node);
    for (int nei : graph.get(node)) {
        dfs(nei, graph, seen);
    }
}
```

## 요약 
- 간선 배열은 인접리스트로 전처리해야한다
- 인접행렬은 간선이 연결되어있는지만 확인

## 그래프 알고리즘 선택 + 시간 복잡도

| 알고리즘 | 시간 복잡도 | 대표 상황 |
|----------|-------------|-----------|
| **DFS / BFS** | `O(N+M)` (인접 리스트), `O(N²)` (인접 행렬) | 탐색, 연결 요소, 경로 |
| **위상 정렬** | `O(N+M)` | 선수 과목, 작업 스케줄링 |
| **Dijkstra** | `O((N+M) log N)` (힙), `O(N²)` (배열) | 양수 가중치 최단거리 |
| **0-1 BFS** | `O(N+M)` | 가중치 0/1 최단거리 |
| **Floyd-Warshall** | `O(N³)` | 모든 쌍 최단거리 (작은 N) |
| **Union-Find (DSU)** | `O(M α(N))` ≈ `O(M)` | 연결 여부, MST, 사이클 판별 |


# 패턴 
