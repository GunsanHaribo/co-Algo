# 문제(회고 필요)

~~~text
두 개의 정수 배열 nums1과 nums2가 오름차순(비내림차순) 으로 정렬되어 있고, 정수 k가 주어집니다.

각 쌍 (u, v)는 첫 번째 배열에서 하나, 두 번째 배열에서 하나의 원소를 선택하여 구성됩니다.

합이 가장 작은 k개의 쌍 (u1, v1), (u2, v2), ..., (uk, vk)을 반환하세요.
~~~

## 문제 분석

1. 미지 : k개의 쌍 반환
2. 자료 : 오름차순인 정수 배열 2개
3. 조건 :

- 합이 가장 작은 k개의 쌍
- nums1, nums2

## 문제 풀이

### Example 1

~~~text
Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
Output: [[1,2],[1,4],[1,6]]
Explanation: The first 3 pairs are returned from the sequence: 
[1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]
~~~

1. 모두 계산해서 넣어버린다. -> 시간초과
2. 경우를 어떻게 계산해서 넣어줘야될까? 100000개를

#### Time Limit Exceeded

- 아마도 지금 2중 for문이여서 문제
    - 다만, num1기준 k개만 한다는 것은 뒤에 숫자중에 num2 최소랑 결합시 안되는게 좀 있음
- 두 배열의 원소를 비교해서 수가 더 큰것을 잡아서 값을 구한다?
- [1, 7, 11], [2, 4, 6]
- 1을 뽑고 [2,4,6] -> [7, 11] [2,4,6]   (1,2 1,4 ,16)
- 2를 뽑고 [7, 11] -> [7, 11] [4, 6]   (2,7, 2,11)
- 4를 뽁고 [7. 11] -> [7, 11] [6]   (4,7, 4,11)
- k 갯수를 채우면 stop, 이게 어느 배열 갯수를 제한해서 뽑을 수 가 없습니다;; 최소가 바뀌어요
- 그리고 할때마다 힙에서 배열을 뽑아줄 수는 없으니 포인터를 사용하겠습니다.


#### 이래도 해결이 안되네
- 일단 완전 투포인터로 진 -> 이래도 터짐
- k까지만 비교하게 한다? -> min(k, length)

### 이래도 안되?
- 

## 링크 

